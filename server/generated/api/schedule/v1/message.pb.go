// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/schedule/v1/message.proto

package schedule

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v12 "github.com/temporalio/ui-server/v2/server/generated/api/common/v1"
	v1 "github.com/temporalio/ui-server/v2/server/generated/api/enums/v1"
	v11 "github.com/temporalio/ui-server/v2/server/generated/api/workflow/v1"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CalendarSpec describes an event specification relative to the calendar,
// similar to a traditional cron specification. Each field can be one of:
//   *: matches always
//   x: matches when the field equals x
//   x/y : matches when the field equals x+n*y where n is an integer
//   x-z: matches when the field is between x and z inclusive
//   w,x,y,...: matches when the field is one of the listed values
// Each x, y, z, ... is either a decimal integer, or a month or day of week name
// or abbreviation (in the appropriate fields).
// A second in time matches if all fields match.
// Note that the special case that some cron implementations have for treating
// day_of_month and day_of_week as "or" instead of "and" when both are set is
// not implemented.
// day_of_week can accept 0 or 7 as Sunday
// TODO: add relative-to-end-of-month
// TODO: add nth day-of-week in month
type CalendarSpec struct {
	// Expression to match seconds. Default: 0
	Second string `protobuf:"bytes,1,opt,name=second,proto3" json:"second,omitempty"`
	// Expression to match minutes. Default: 0
	Minute string `protobuf:"bytes,2,opt,name=minute,proto3" json:"minute,omitempty"`
	// Expression to match hours. Default: 0
	Hour string `protobuf:"bytes,3,opt,name=hour,proto3" json:"hour,omitempty"`
	// Expression to match days of the month. Default: *
	// (-- api-linter: core::0140::prepositions=disabled
	//     aip.dev/not-precedent: standard name of field --)
	DayOfMonth string `protobuf:"bytes,4,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// Expression to match months. Default: *
	Month string `protobuf:"bytes,5,opt,name=month,proto3" json:"month,omitempty"`
	// Expression to match years. Default: *
	Year string `protobuf:"bytes,6,opt,name=year,proto3" json:"year,omitempty"`
	// Expression to match days of the week. Default: *
	DayOfWeek string `protobuf:"bytes,7,opt,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
}

func (m *CalendarSpec) Reset()      { *m = CalendarSpec{} }
func (*CalendarSpec) ProtoMessage() {}
func (*CalendarSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{0}
}
func (m *CalendarSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalendarSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalendarSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalendarSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalendarSpec.Merge(m, src)
}
func (m *CalendarSpec) XXX_Size() int {
	return m.Size()
}
func (m *CalendarSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CalendarSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CalendarSpec proto.InternalMessageInfo

func (m *CalendarSpec) GetSecond() string {
	if m != nil {
		return m.Second
	}
	return ""
}

func (m *CalendarSpec) GetMinute() string {
	if m != nil {
		return m.Minute
	}
	return ""
}

func (m *CalendarSpec) GetHour() string {
	if m != nil {
		return m.Hour
	}
	return ""
}

func (m *CalendarSpec) GetDayOfMonth() string {
	if m != nil {
		return m.DayOfMonth
	}
	return ""
}

func (m *CalendarSpec) GetMonth() string {
	if m != nil {
		return m.Month
	}
	return ""
}

func (m *CalendarSpec) GetYear() string {
	if m != nil {
		return m.Year
	}
	return ""
}

func (m *CalendarSpec) GetDayOfWeek() string {
	if m != nil {
		return m.DayOfWeek
	}
	return ""
}

// IntervalSpec matches times that can be expressed as:
// epoch + n * interval + phase
// where n is an integer.
// phase defaults to zero if missing. interval is required.
// Both interval and phase must be non-negative and are truncated to the nearest
// second before any calculations.
// For example, an interval of 1 hour with phase of zero would match every hour,
// on the hour. The same interval but a phase of 19 minutes would match every
// xx:19:00. An interval of 28 days with phase zero would match
// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
type IntervalSpec struct {
	Interval *time.Duration `protobuf:"bytes,1,opt,name=interval,proto3,stdduration" json:"interval,omitempty"`
	Phase    *time.Duration `protobuf:"bytes,2,opt,name=phase,proto3,stdduration" json:"phase,omitempty"`
}

func (m *IntervalSpec) Reset()      { *m = IntervalSpec{} }
func (*IntervalSpec) ProtoMessage() {}
func (*IntervalSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{1}
}
func (m *IntervalSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntervalSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntervalSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntervalSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalSpec.Merge(m, src)
}
func (m *IntervalSpec) XXX_Size() int {
	return m.Size()
}
func (m *IntervalSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalSpec proto.InternalMessageInfo

func (m *IntervalSpec) GetInterval() *time.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *IntervalSpec) GetPhase() *time.Duration {
	if m != nil {
		return m.Phase
	}
	return nil
}

// ScheduleSpec is a complete description of a set of absolute timestamps
// (possibly infinite) that an action should occur at. The meaning of a
// ScheduleSpec depends only on its contents and never changes, except that the
// definition of a time zone can change over time (most commonly, when daylight
// saving time policy changes for an area). To create a totally self-contained
// ScheduleSpec, use UTC or include timezone_data.
type ScheduleSpec struct {
	// Calendar-based specifications of times.
	Calendar []*CalendarSpec `protobuf:"bytes,1,rep,name=calendar,proto3" json:"calendar,omitempty"`
	// Interval-based specifications of times.
	Interval []*IntervalSpec `protobuf:"bytes,2,rep,name=interval,proto3" json:"interval,omitempty"`
	// Any timestamps matching any of the exclude_calendar specs will be
	// skipped.
	ExcludeCalendar []*CalendarSpec `protobuf:"bytes,3,rep,name=exclude_calendar,json=excludeCalendar,proto3" json:"exclude_calendar,omitempty"`
	// Any timestamps before start_time will be skipped. Together, start_time
	// and end_time make an inclusive interval.
	StartTime *time.Time `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	// Any timestamps after end_time will be skipped.
	EndTime *time.Time `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// All timestamps will be incremented by a random value from 0 to this
	// amount of jitter. Default: 1 second
	Jitter *time.Duration `protobuf:"bytes,6,opt,name=jitter,proto3,stdduration" json:"jitter,omitempty"`
	// Time zone to interpret all CalendarSpecs in.
	//
	// If unset, defaults to UTC. We recommend using UTC for your application if
	// at all possible, to avoid various surprising properties of time zones.
	//
	// Time zones may be provided by name, corresponding to names in the IANA
	// time zone database (see https://www.iana.org/time-zones). The definition
	// will be loaded by the Temporal server from the environment it runs in.
	//
	// If your application requires more control over the time zone definition
	// used, it may pass in a complete definition in the form of a TZif file
	// from the time zone database. If present, this will be used instead of
	// loading anything from the environment. You are then responsible for
	// updating timezone_data when the definition changes.
	//
	// Calendar spec matching is based on literal matching of the clock time
	// with no special handling of DST: if you write a calendar spec that fires
	// at 2:30am and specify a time zone that follows DST, that action will not
	// be triggered on the day that has no 2:30am. Similarly, an action that
	// fires at 1:30am will be triggered twice on the day that has two 1:30s.
	TimezoneName string `protobuf:"bytes,10,opt,name=timezone_name,json=timezoneName,proto3" json:"timezone_name,omitempty"`
	TimezoneData []byte `protobuf:"bytes,11,opt,name=timezone_data,json=timezoneData,proto3" json:"timezone_data,omitempty"`
}

func (m *ScheduleSpec) Reset()      { *m = ScheduleSpec{} }
func (*ScheduleSpec) ProtoMessage() {}
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{2}
}
func (m *ScheduleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleSpec.Merge(m, src)
}
func (m *ScheduleSpec) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleSpec proto.InternalMessageInfo

func (m *ScheduleSpec) GetCalendar() []*CalendarSpec {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *ScheduleSpec) GetInterval() []*IntervalSpec {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *ScheduleSpec) GetExcludeCalendar() []*CalendarSpec {
	if m != nil {
		return m.ExcludeCalendar
	}
	return nil
}

func (m *ScheduleSpec) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ScheduleSpec) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ScheduleSpec) GetJitter() *time.Duration {
	if m != nil {
		return m.Jitter
	}
	return nil
}

func (m *ScheduleSpec) GetTimezoneName() string {
	if m != nil {
		return m.TimezoneName
	}
	return ""
}

func (m *ScheduleSpec) GetTimezoneData() []byte {
	if m != nil {
		return m.TimezoneData
	}
	return nil
}

type SchedulePolicies struct {
	// Policy for overlaps.
	// Note that this can be changed after a schedule has taken some actions, and we can't
	// provide 100% sensible semantics for all changes. The most confusing case would be
	// changes to/from ALLOW_ALL: with that policy multiple scheduled workflows can run
	// concurrently, but for all other policies only one can run at a time. Changing
	// between these two classes will leave all workflows with the other class alone.
	// E.g., if changing from ALLOW_ALL to CANCEL_OTHER, and there are workflows running,
	// those workflows will not be cancelled. If changing from ALLOW_ALL to SKIP with
	// workflows running, the running workflows will not cause the next action to be
	// skipped.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Policy for catchups:
	// If the Temporal server misses an action due to one or more components
	// being down, and comes back up, the action will be run if the scheduled
	// time is within this window from the current time.
	// This value defaults to 60 seconds, and can't be less than 10 seconds.
	CatchupWindow *time.Duration `protobuf:"bytes,2,opt,name=catchup_window,json=catchupWindow,proto3,stdduration" json:"catchup_window,omitempty"`
	// If true, and a workflow run fails or times out, turn on "paused".
	// This applies after retry policies: the full chain of retries must fail to
	// trigger a pause here.
	PauseOnFailure bool `protobuf:"varint,3,opt,name=pause_on_failure,json=pauseOnFailure,proto3" json:"pause_on_failure,omitempty"`
}

func (m *SchedulePolicies) Reset()      { *m = SchedulePolicies{} }
func (*SchedulePolicies) ProtoMessage() {}
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{3}
}
func (m *SchedulePolicies) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePolicies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePolicies.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePolicies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePolicies.Merge(m, src)
}
func (m *SchedulePolicies) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePolicies) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePolicies.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePolicies proto.InternalMessageInfo

func (m *SchedulePolicies) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

func (m *SchedulePolicies) GetCatchupWindow() *time.Duration {
	if m != nil {
		return m.CatchupWindow
	}
	return nil
}

func (m *SchedulePolicies) GetPauseOnFailure() bool {
	if m != nil {
		return m.PauseOnFailure
	}
	return false
}

type ScheduleAction struct {
	// Types that are valid to be assigned to Action:
	//	*ScheduleAction_StartWorkflow
	Action isScheduleAction_Action `protobuf_oneof:"action"`
}

func (m *ScheduleAction) Reset()      { *m = ScheduleAction{} }
func (*ScheduleAction) ProtoMessage() {}
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{4}
}
func (m *ScheduleAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleAction.Merge(m, src)
}
func (m *ScheduleAction) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleAction.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleAction proto.InternalMessageInfo

type isScheduleAction_Action interface {
	isScheduleAction_Action()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScheduleAction_StartWorkflow struct {
	StartWorkflow *v11.NewWorkflowExecutionInfo `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3,oneof" json:"start_workflow,omitempty"`
}

func (*ScheduleAction_StartWorkflow) isScheduleAction_Action() {}

func (m *ScheduleAction) GetAction() isScheduleAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ScheduleAction) GetStartWorkflow() *v11.NewWorkflowExecutionInfo {
	if x, ok := m.GetAction().(*ScheduleAction_StartWorkflow); ok {
		return x.StartWorkflow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScheduleAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScheduleAction_StartWorkflow)(nil),
	}
}

type ScheduleActionResult struct {
	// Time that the action was taken (according to the schedule, including jitter).
	ScheduleTime *time.Time `protobuf:"bytes,1,opt,name=schedule_time,json=scheduleTime,proto3,stdtime" json:"schedule_time,omitempty"`
	// Time that the action was taken (real time).
	ActualTime *time.Time `protobuf:"bytes,2,opt,name=actual_time,json=actualTime,proto3,stdtime" json:"actual_time,omitempty"`
	// If action was start_workflow:
	StartWorkflowResult *v12.WorkflowExecution `protobuf:"bytes,11,opt,name=start_workflow_result,json=startWorkflowResult,proto3" json:"start_workflow_result,omitempty"`
}

func (m *ScheduleActionResult) Reset()      { *m = ScheduleActionResult{} }
func (*ScheduleActionResult) ProtoMessage() {}
func (*ScheduleActionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{5}
}
func (m *ScheduleActionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleActionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleActionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleActionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleActionResult.Merge(m, src)
}
func (m *ScheduleActionResult) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleActionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleActionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleActionResult proto.InternalMessageInfo

func (m *ScheduleActionResult) GetScheduleTime() *time.Time {
	if m != nil {
		return m.ScheduleTime
	}
	return nil
}

func (m *ScheduleActionResult) GetActualTime() *time.Time {
	if m != nil {
		return m.ActualTime
	}
	return nil
}

func (m *ScheduleActionResult) GetStartWorkflowResult() *v12.WorkflowExecution {
	if m != nil {
		return m.StartWorkflowResult
	}
	return nil
}

type ScheduleState struct {
	// Informative human-readable message with contextual notes, e.g. the reason
	// a schedule is paused. The system may overwrite this message on certain
	// conditions, e.g. when pause-on-failure happens.
	Notes string `protobuf:"bytes,1,opt,name=notes,proto3" json:"notes,omitempty"`
	// If true, do not take any actions based on the schedule spec.
	Paused bool `protobuf:"varint,2,opt,name=paused,proto3" json:"paused,omitempty"`
	// If limited_actions is true, decrement remaining_actions after each action, and do
	// not take any more scheduled actions if remaining_actions is zero. Actions may still
	// be taken by explicit request. Skipped actions (due to overlap policy) do not count
	// against remaining actions.
	LimitedActions   bool  `protobuf:"varint,3,opt,name=limited_actions,json=limitedActions,proto3" json:"limited_actions,omitempty"`
	RemainingActions int64 `protobuf:"varint,4,opt,name=remaining_actions,json=remainingActions,proto3" json:"remaining_actions,omitempty"`
}

func (m *ScheduleState) Reset()      { *m = ScheduleState{} }
func (*ScheduleState) ProtoMessage() {}
func (*ScheduleState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{6}
}
func (m *ScheduleState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleState.Merge(m, src)
}
func (m *ScheduleState) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleState) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleState.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleState proto.InternalMessageInfo

func (m *ScheduleState) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *ScheduleState) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ScheduleState) GetLimitedActions() bool {
	if m != nil {
		return m.LimitedActions
	}
	return false
}

func (m *ScheduleState) GetRemainingActions() int64 {
	if m != nil {
		return m.RemainingActions
	}
	return 0
}

type TriggerImmediatelyRequest struct {
	// Override overlap policy for this one request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (m *TriggerImmediatelyRequest) Reset()      { *m = TriggerImmediatelyRequest{} }
func (*TriggerImmediatelyRequest) ProtoMessage() {}
func (*TriggerImmediatelyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{7}
}
func (m *TriggerImmediatelyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerImmediatelyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerImmediatelyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerImmediatelyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerImmediatelyRequest.Merge(m, src)
}
func (m *TriggerImmediatelyRequest) XXX_Size() int {
	return m.Size()
}
func (m *TriggerImmediatelyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerImmediatelyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerImmediatelyRequest proto.InternalMessageInfo

func (m *TriggerImmediatelyRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

type BackfillRequest struct {
	// Time range to evaluate schedule in.
	StartTime *time.Time `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	EndTime   *time.Time `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// Override overlap policy for this request.
	OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,3,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
}

func (m *BackfillRequest) Reset()      { *m = BackfillRequest{} }
func (*BackfillRequest) ProtoMessage() {}
func (*BackfillRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{8}
}
func (m *BackfillRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackfillRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackfillRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillRequest.Merge(m, src)
}
func (m *BackfillRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackfillRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillRequest proto.InternalMessageInfo

func (m *BackfillRequest) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *BackfillRequest) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *BackfillRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return v1.SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
}

type SchedulePatch struct {
	// If set, trigger one action immediately.
	TriggerImmediately *TriggerImmediatelyRequest `protobuf:"bytes,1,opt,name=trigger_immediately,json=triggerImmediately,proto3" json:"trigger_immediately,omitempty"`
	// If set, runs though the specified time period(s) and takes actions as if that time
	// passed by right now, all at once. The overlap policy can be overridden for the
	// scope of the backfill.
	BackfillRequest []*BackfillRequest `protobuf:"bytes,2,rep,name=backfill_request,json=backfillRequest,proto3" json:"backfill_request,omitempty"`
	// If set, change the state to paused or unpaused (respectively) and set the
	// notes field to the value of the string.
	Pause   string `protobuf:"bytes,3,opt,name=pause,proto3" json:"pause,omitempty"`
	Unpause string `protobuf:"bytes,4,opt,name=unpause,proto3" json:"unpause,omitempty"`
}

func (m *SchedulePatch) Reset()      { *m = SchedulePatch{} }
func (*SchedulePatch) ProtoMessage() {}
func (*SchedulePatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{9}
}
func (m *SchedulePatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePatch.Merge(m, src)
}
func (m *SchedulePatch) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePatch.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePatch proto.InternalMessageInfo

func (m *SchedulePatch) GetTriggerImmediately() *TriggerImmediatelyRequest {
	if m != nil {
		return m.TriggerImmediately
	}
	return nil
}

func (m *SchedulePatch) GetBackfillRequest() []*BackfillRequest {
	if m != nil {
		return m.BackfillRequest
	}
	return nil
}

func (m *SchedulePatch) GetPause() string {
	if m != nil {
		return m.Pause
	}
	return ""
}

func (m *SchedulePatch) GetUnpause() string {
	if m != nil {
		return m.Unpause
	}
	return ""
}

type ScheduleInfo struct {
	// Number of actions taken so far.
	ActionCount int64 `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3" json:"action_count,omitempty"`
	// Number of times a scheduled action was skipped due to missing the catchup window.
	MissedCatchupWindow int64 `protobuf:"varint,2,opt,name=missed_catchup_window,json=missedCatchupWindow,proto3" json:"missed_catchup_window,omitempty"`
	// Number of skipped actions due to overlap.
	OverlapSkipped int64 `protobuf:"varint,3,opt,name=overlap_skipped,json=overlapSkipped,proto3" json:"overlap_skipped,omitempty"`
	// Currently-running workflows started by this schedule. (There might be
	// more than one if the overlap policy allows overlaps.)
	// Note that the run_ids in here are the original execution run ids as
	// started by the schedule. If the workflows retried, did continue-as-new,
	// or were reset, they might still be running but with a different run_id.
	RunningWorkflows []*v12.WorkflowExecution `protobuf:"bytes,9,rep,name=running_workflows,json=runningWorkflows,proto3" json:"running_workflows,omitempty"`
	// Most recent ten actual action times (including manual triggers).
	RecentActions []*ScheduleActionResult `protobuf:"bytes,4,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	// Next ten scheduled action times.
	FutureActionTimes []*time.Time `protobuf:"bytes,5,rep,name=future_action_times,json=futureActionTimes,proto3,stdtime" json:"future_action_times,omitempty"`
	// Timestamps of schedule creation and last update.
	CreateTime *time.Time `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time,omitempty"`
	UpdateTime *time.Time `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3,stdtime" json:"update_time,omitempty"`
	// Error for invalid schedule. If this is set, no actions will be taken.
	InvalidScheduleError string `protobuf:"bytes,8,opt,name=invalid_schedule_error,json=invalidScheduleError,proto3" json:"invalid_schedule_error,omitempty"`
}

func (m *ScheduleInfo) Reset()      { *m = ScheduleInfo{} }
func (*ScheduleInfo) ProtoMessage() {}
func (*ScheduleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{10}
}
func (m *ScheduleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleInfo.Merge(m, src)
}
func (m *ScheduleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleInfo proto.InternalMessageInfo

func (m *ScheduleInfo) GetActionCount() int64 {
	if m != nil {
		return m.ActionCount
	}
	return 0
}

func (m *ScheduleInfo) GetMissedCatchupWindow() int64 {
	if m != nil {
		return m.MissedCatchupWindow
	}
	return 0
}

func (m *ScheduleInfo) GetOverlapSkipped() int64 {
	if m != nil {
		return m.OverlapSkipped
	}
	return 0
}

func (m *ScheduleInfo) GetRunningWorkflows() []*v12.WorkflowExecution {
	if m != nil {
		return m.RunningWorkflows
	}
	return nil
}

func (m *ScheduleInfo) GetRecentActions() []*ScheduleActionResult {
	if m != nil {
		return m.RecentActions
	}
	return nil
}

func (m *ScheduleInfo) GetFutureActionTimes() []*time.Time {
	if m != nil {
		return m.FutureActionTimes
	}
	return nil
}

func (m *ScheduleInfo) GetCreateTime() *time.Time {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *ScheduleInfo) GetUpdateTime() *time.Time {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *ScheduleInfo) GetInvalidScheduleError() string {
	if m != nil {
		return m.InvalidScheduleError
	}
	return ""
}

type Schedule struct {
	Spec     *ScheduleSpec     `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Action   *ScheduleAction   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Policies *SchedulePolicies `protobuf:"bytes,3,opt,name=policies,proto3" json:"policies,omitempty"`
	State    *ScheduleState    `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *Schedule) Reset()      { *m = Schedule{} }
func (*Schedule) ProtoMessage() {}
func (*Schedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{11}
}
func (m *Schedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedule.Merge(m, src)
}
func (m *Schedule) XXX_Size() int {
	return m.Size()
}
func (m *Schedule) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedule.DiscardUnknown(m)
}

var xxx_messageInfo_Schedule proto.InternalMessageInfo

func (m *Schedule) GetSpec() *ScheduleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Schedule) GetAction() *ScheduleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Schedule) GetPolicies() *SchedulePolicies {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *Schedule) GetState() *ScheduleState {
	if m != nil {
		return m.State
	}
	return nil
}

// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
// that's returned in ListSchedules.
type ScheduleListInfo struct {
	// From spec:
	// Some fields are too large/unimportant for the purpose of listing, so we'll clear them
	// from this copy of spec: exclude_calendar, jitter, timezone_data.
	Spec *ScheduleSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// From action:
	// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
	// well with JSON. If action is start_workflow, this is set:
	WorkflowType *v12.WorkflowType `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// From state:
	Notes  string `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	Paused bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	// From info (maybe fewer entries):
	RecentActions     []*ScheduleActionResult `protobuf:"bytes,5,rep,name=recent_actions,json=recentActions,proto3" json:"recent_actions,omitempty"`
	FutureActionTimes []*time.Time            `protobuf:"bytes,6,rep,name=future_action_times,json=futureActionTimes,proto3,stdtime" json:"future_action_times,omitempty"`
}

func (m *ScheduleListInfo) Reset()      { *m = ScheduleListInfo{} }
func (*ScheduleListInfo) ProtoMessage() {}
func (*ScheduleListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{12}
}
func (m *ScheduleListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleListInfo.Merge(m, src)
}
func (m *ScheduleListInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleListInfo proto.InternalMessageInfo

func (m *ScheduleListInfo) GetSpec() *ScheduleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ScheduleListInfo) GetWorkflowType() *v12.WorkflowType {
	if m != nil {
		return m.WorkflowType
	}
	return nil
}

func (m *ScheduleListInfo) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *ScheduleListInfo) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ScheduleListInfo) GetRecentActions() []*ScheduleActionResult {
	if m != nil {
		return m.RecentActions
	}
	return nil
}

func (m *ScheduleListInfo) GetFutureActionTimes() []*time.Time {
	if m != nil {
		return m.FutureActionTimes
	}
	return nil
}

// ScheduleListEntry is returned by ListSchedules.
type ScheduleListEntry struct {
	ScheduleId       string                `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Memo             *v12.Memo             `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	SearchAttributes *v12.SearchAttributes `protobuf:"bytes,3,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	Info             *ScheduleListInfo     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *ScheduleListEntry) Reset()      { *m = ScheduleListEntry{} }
func (*ScheduleListEntry) ProtoMessage() {}
func (*ScheduleListEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6aeef3f4b308dee, []int{13}
}
func (m *ScheduleListEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleListEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleListEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleListEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleListEntry.Merge(m, src)
}
func (m *ScheduleListEntry) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleListEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleListEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleListEntry proto.InternalMessageInfo

func (m *ScheduleListEntry) GetScheduleId() string {
	if m != nil {
		return m.ScheduleId
	}
	return ""
}

func (m *ScheduleListEntry) GetMemo() *v12.Memo {
	if m != nil {
		return m.Memo
	}
	return nil
}

func (m *ScheduleListEntry) GetSearchAttributes() *v12.SearchAttributes {
	if m != nil {
		return m.SearchAttributes
	}
	return nil
}

func (m *ScheduleListEntry) GetInfo() *ScheduleListInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterType((*CalendarSpec)(nil), "temporal.api.schedule.v1.CalendarSpec")
	proto.RegisterType((*IntervalSpec)(nil), "temporal.api.schedule.v1.IntervalSpec")
	proto.RegisterType((*ScheduleSpec)(nil), "temporal.api.schedule.v1.ScheduleSpec")
	proto.RegisterType((*SchedulePolicies)(nil), "temporal.api.schedule.v1.SchedulePolicies")
	proto.RegisterType((*ScheduleAction)(nil), "temporal.api.schedule.v1.ScheduleAction")
	proto.RegisterType((*ScheduleActionResult)(nil), "temporal.api.schedule.v1.ScheduleActionResult")
	proto.RegisterType((*ScheduleState)(nil), "temporal.api.schedule.v1.ScheduleState")
	proto.RegisterType((*TriggerImmediatelyRequest)(nil), "temporal.api.schedule.v1.TriggerImmediatelyRequest")
	proto.RegisterType((*BackfillRequest)(nil), "temporal.api.schedule.v1.BackfillRequest")
	proto.RegisterType((*SchedulePatch)(nil), "temporal.api.schedule.v1.SchedulePatch")
	proto.RegisterType((*ScheduleInfo)(nil), "temporal.api.schedule.v1.ScheduleInfo")
	proto.RegisterType((*Schedule)(nil), "temporal.api.schedule.v1.Schedule")
	proto.RegisterType((*ScheduleListInfo)(nil), "temporal.api.schedule.v1.ScheduleListInfo")
	proto.RegisterType((*ScheduleListEntry)(nil), "temporal.api.schedule.v1.ScheduleListEntry")
}

func init() {
	proto.RegisterFile("temporal/api/schedule/v1/message.proto", fileDescriptor_e6aeef3f4b308dee)
}

var fileDescriptor_e6aeef3f4b308dee = []byte{
	// 1494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4b, 0x6f, 0x1b, 0x45,
	0x1c, 0xcf, 0xfa, 0x91, 0x38, 0x63, 0x3b, 0x8f, 0x49, 0x5a, 0x6d, 0x5b, 0xb4, 0x0d, 0xa6, 0x6a,
	0x53, 0xa0, 0x36, 0x71, 0x41, 0x48, 0xa9, 0x78, 0x24, 0x6d, 0x2a, 0x22, 0xf5, 0x11, 0x36, 0x69,
	0x2b, 0x81, 0xd0, 0x6a, 0xb2, 0x3b, 0x76, 0x86, 0xec, 0xee, 0x2c, 0xbb, 0xb3, 0x71, 0xcd, 0x09,
	0xf1, 0x05, 0xa8, 0xc4, 0x85, 0x8f, 0x80, 0xf8, 0x10, 0x9c, 0x91, 0xb8, 0xf4, 0x58, 0x4e, 0xd0,
	0x94, 0x43, 0xd5, 0x53, 0xef, 0x08, 0x81, 0xe6, 0xb5, 0xb1, 0xe3, 0x98, 0xb8, 0x54, 0xbd, 0xed,
	0xfc, 0x1f, 0xbf, 0x99, 0xff, 0xef, 0xff, 0x98, 0x59, 0x70, 0x9e, 0xe1, 0x20, 0xa2, 0x31, 0xf2,
	0x1b, 0x28, 0x22, 0x8d, 0xc4, 0xdd, 0xc1, 0x5e, 0xea, 0xe3, 0xc6, 0xde, 0x52, 0x23, 0xc0, 0x49,
	0x82, 0xda, 0xb8, 0x1e, 0xc5, 0x94, 0x51, 0x68, 0x6a, 0xbb, 0x3a, 0x8a, 0x48, 0x5d, 0xdb, 0xd5,
	0xf7, 0x96, 0x4e, 0x5b, 0x6d, 0x4a, 0xdb, 0x3e, 0x6e, 0x08, 0xbb, 0xed, 0xb4, 0xd5, 0xf0, 0xd2,
	0x18, 0x31, 0x42, 0x43, 0xe9, 0x79, 0xfa, 0xec, 0x61, 0x3d, 0x23, 0x01, 0x4e, 0x18, 0x0a, 0x22,
	0x65, 0x70, 0xa9, 0x4d, 0xd8, 0x4e, 0xba, 0x5d, 0x77, 0x69, 0xd0, 0x68, 0xd3, 0x36, 0x3d, 0xb0,
	0xe4, 0x2b, 0xb1, 0x10, 0x5f, 0xca, 0xfc, 0x5c, 0xdf, 0x89, 0x5d, 0x1a, 0x04, 0x34, 0x1c, 0x38,
	0xef, 0x21, 0x2b, 0x1c, 0xa6, 0x41, 0xc2, 0x8d, 0xb2, 0x83, 0x4b, 0xab, 0xfe, 0xe8, 0x3b, 0x34,
	0xde, 0x6d, 0xf9, 0xb4, 0x33, 0x80, 0x56, 0xfb, 0xd9, 0x00, 0x95, 0xab, 0xc8, 0xc7, 0xa1, 0x87,
	0xe2, 0xcd, 0x08, 0xbb, 0xf0, 0x24, 0x18, 0x4f, 0xb0, 0x4b, 0x43, 0xcf, 0x34, 0x16, 0x8c, 0xc5,
	0x49, 0x5b, 0xad, 0xb8, 0x3c, 0x20, 0x61, 0xca, 0xb0, 0x99, 0x93, 0x72, 0xb9, 0x82, 0x10, 0x14,
	0x76, 0x68, 0x1a, 0x9b, 0x79, 0x21, 0x15, 0xdf, 0x70, 0x01, 0x54, 0x3c, 0xd4, 0x75, 0x68, 0xcb,
	0x09, 0x68, 0xc8, 0x76, 0xcc, 0x82, 0xd0, 0x01, 0x0f, 0x75, 0x6f, 0xb7, 0x6e, 0x72, 0x09, 0x9c,
	0x07, 0x45, 0xa9, 0x2a, 0x0a, 0x95, 0x5c, 0x70, 0xac, 0x2e, 0x46, 0xb1, 0x39, 0x2e, 0xb1, 0xf8,
	0x37, 0xb4, 0x40, 0x59, 0x61, 0x75, 0x30, 0xde, 0x35, 0x27, 0x84, 0x6a, 0x52, 0x40, 0xdd, 0xc3,
	0x78, 0xb7, 0xf6, 0xad, 0x01, 0x2a, 0xeb, 0x21, 0xc3, 0xf1, 0x1e, 0xf2, 0x45, 0x00, 0x57, 0x40,
	0x89, 0xa8, 0xb5, 0x08, 0xa1, 0xdc, 0x3c, 0x55, 0x97, 0x89, 0xaa, 0x6b, 0xfa, 0xeb, 0xd7, 0x54,
	0x22, 0x57, 0x0b, 0x3f, 0xfc, 0x7e, 0xd6, 0xb0, 0x33, 0x07, 0xf8, 0x1e, 0x28, 0x46, 0x3b, 0x28,
	0x91, 0x41, 0x8e, 0xe0, 0x29, 0xad, 0x6b, 0xcf, 0xf2, 0xa0, 0xb2, 0xa9, 0x12, 0x20, 0x0e, 0xb1,
	0x0a, 0x4a, 0xae, 0x62, 0xd5, 0x34, 0x16, 0xf2, 0x8b, 0xe5, 0xe6, 0xf9, 0xfa, 0xb0, 0x3a, 0xab,
	0xf7, 0xf2, 0x6f, 0x67, 0x7e, 0x1c, 0x23, 0x0b, 0x24, 0x77, 0x1c, 0x46, 0x2f, 0x05, 0x3d, 0xf1,
	0x7c, 0x0a, 0x66, 0xf0, 0x7d, 0xd7, 0x4f, 0x3d, 0xec, 0x64, 0xe7, 0xc9, 0xbf, 0xd0, 0x79, 0xa6,
	0x95, 0xbf, 0x16, 0xc2, 0x8f, 0x00, 0x48, 0x18, 0x8a, 0x99, 0xc3, 0xab, 0x5d, 0xa4, 0xb6, 0xdc,
	0x3c, 0x3d, 0xc0, 0xd3, 0x96, 0x6e, 0x85, 0xd5, 0xc2, 0x03, 0x4e, 0xd4, 0xa4, 0xf0, 0xe1, 0x52,
	0x9e, 0x20, 0x1c, 0x7a, 0xd2, 0xbd, 0x38, 0xa2, 0xfb, 0x04, 0x0e, 0x3d, 0xe1, 0xfc, 0x3e, 0x18,
	0xff, 0x92, 0x30, 0x86, 0x65, 0x91, 0x8c, 0x90, 0x21, 0x65, 0x0e, 0xdf, 0x00, 0x55, 0xbe, 0xe3,
	0xd7, 0x34, 0xc4, 0x4e, 0x88, 0x02, 0x6c, 0x02, 0x51, 0x49, 0x15, 0x2d, 0xbc, 0x85, 0x02, 0xdc,
	0x67, 0xe4, 0x21, 0x86, 0xcc, 0xf2, 0x82, 0xb1, 0x58, 0x39, 0x30, 0xba, 0x86, 0x18, 0xaa, 0xfd,
	0x66, 0x80, 0x19, 0x9d, 0xec, 0x0d, 0xea, 0x13, 0x97, 0xe0, 0x04, 0x6e, 0x82, 0x29, 0xba, 0x87,
	0x63, 0x1f, 0x45, 0x4e, 0xc4, 0x65, 0x5d, 0x51, 0x7b, 0x53, 0xcd, 0xb7, 0xfb, 0x69, 0x16, 0xed,
	0xca, 0x39, 0xd6, 0x00, 0xb7, 0xa5, 0x93, 0xc0, 0xe9, 0xda, 0x55, 0xda, 0xbb, 0x84, 0xd7, 0xc1,
	0x94, 0x8b, 0x98, 0xbb, 0x93, 0x46, 0x4e, 0x87, 0x84, 0x1e, 0xed, 0x8c, 0x5a, 0x96, 0x55, 0xe5,
	0x76, 0x4f, 0x78, 0xc1, 0x45, 0x30, 0x13, 0xa1, 0x34, 0xc1, 0x0e, 0x0d, 0x9d, 0x16, 0x22, 0x7e,
	0x1a, 0x63, 0xd1, 0xaf, 0x25, 0x7b, 0x4a, 0xc8, 0x6f, 0x87, 0xd7, 0xa5, 0xb4, 0xd6, 0x01, 0x53,
	0xfa, 0x64, 0x2b, 0x2e, 0x07, 0x84, 0x9f, 0x83, 0x29, 0x99, 0x6e, 0x3d, 0x43, 0x54, 0x53, 0x35,
	0xfb, 0x03, 0xd3, 0x5a, 0x1e, 0xdb, 0x2d, 0xdc, 0xb9, 0xa7, 0x96, 0x6b, 0xf7, 0xb1, 0x9b, 0x72,
	0x9c, 0xf5, 0xb0, 0x45, 0x3f, 0x19, 0xb3, 0xab, 0x02, 0x4b, 0x6b, 0x57, 0x4b, 0x60, 0x1c, 0x89,
	0x6d, 0x6a, 0xff, 0x18, 0x60, 0xbe, 0x7f, 0x67, 0x1b, 0x27, 0xa9, 0xcf, 0xe0, 0x1a, 0xa8, 0xea,
	0xda, 0x94, 0x25, 0x63, 0x8c, 0x58, 0x32, 0x15, 0xed, 0x26, 0xea, 0x66, 0x05, 0x94, 0x91, 0xcb,
	0x52, 0xe4, 0x4b, 0x90, 0xdc, 0x88, 0x20, 0x40, 0x3a, 0x09, 0x88, 0x2f, 0xc0, 0x89, 0x7e, 0x26,
	0x9c, 0x58, 0x1c, 0x51, 0x14, 0x49, 0xb9, 0x79, 0xb1, 0x9f, 0x10, 0x39, 0xbe, 0x39, 0x1d, 0x03,
	0x5c, 0xd8, 0x73, 0x7d, 0x2c, 0xc8, 0x40, 0x6b, 0xdf, 0x1b, 0xa0, 0x9a, 0xcd, 0x10, 0x86, 0x18,
	0xe6, 0x43, 0x32, 0xa4, 0x0c, 0x27, 0x6a, 0x12, 0xcb, 0x05, 0x1f, 0xc4, 0x22, 0x69, 0x9e, 0x08,
	0xa2, 0x64, 0xab, 0x15, 0xbc, 0x00, 0xa6, 0x7d, 0x12, 0x10, 0x86, 0x3d, 0x47, 0x72, 0x9a, 0xe8,
	0x1c, 0x2b, 0xb1, 0xa4, 0x35, 0x81, 0x6f, 0x81, 0xd9, 0x18, 0x07, 0x88, 0x84, 0x24, 0x6c, 0x67,
	0xa6, 0xbc, 0x8f, 0xf3, 0xf6, 0x4c, 0xa6, 0x50, 0xc6, 0xb5, 0x08, 0x9c, 0xda, 0x8a, 0x49, 0xbb,
	0x8d, 0xe3, 0xf5, 0x20, 0xc0, 0x1e, 0x41, 0x0c, 0xfb, 0x5d, 0x1b, 0x7f, 0x95, 0xe2, 0x84, 0xbd,
	0x92, 0xa2, 0xaf, 0xfd, 0x69, 0x80, 0xe9, 0x55, 0xe4, 0xee, 0xb6, 0x88, 0xef, 0xeb, 0x8d, 0xfa,
	0x67, 0x8e, 0xf1, 0x72, 0x33, 0x27, 0xf7, 0xa2, 0x33, 0x67, 0x30, 0xcc, 0xfc, 0xcb, 0x87, 0xf9,
	0x57, 0x4f, 0xba, 0x37, 0x78, 0xb7, 0x42, 0x0f, 0xcc, 0x31, 0x49, 0xb5, 0x43, 0x0e, 0xb8, 0x56,
	0xd1, 0x5e, 0x1e, 0x3e, 0xae, 0x87, 0xe6, 0xc7, 0x86, 0x6c, 0x40, 0x05, 0xb7, 0xc0, 0xcc, 0xb6,
	0x62, 0xd7, 0x89, 0xa5, 0x9d, 0xba, 0x5d, 0x2e, 0x0e, 0xdf, 0xe2, 0x50, 0x3e, 0xec, 0xe9, 0xed,
	0x43, 0x09, 0x9a, 0x07, 0x45, 0x51, 0x86, 0xea, 0x19, 0x20, 0x17, 0xd0, 0x04, 0x13, 0x69, 0x28,
	0xe5, 0xf2, 0x09, 0xa0, 0x97, 0xb5, 0x5f, 0x0b, 0x07, 0x17, 0x26, 0x1f, 0x0d, 0xf0, 0x75, 0x50,
	0x91, 0xa5, 0xe8, 0xb8, 0x34, 0x0d, 0x99, 0x88, 0x3a, 0x6f, 0x97, 0xa5, 0xec, 0x2a, 0x17, 0xc1,
	0x26, 0x38, 0x11, 0x90, 0x24, 0xc1, 0x9e, 0x73, 0xc4, 0x50, 0xcc, 0xdb, 0x73, 0x52, 0x79, 0xb5,
	0x6f, 0xf2, 0x5d, 0x00, 0xd3, 0x3a, 0x75, 0xc9, 0x2e, 0x89, 0x22, 0xec, 0x89, 0x13, 0xe6, 0x6d,
	0x9d, 0xd1, 0x4d, 0x29, 0x85, 0x77, 0xc1, 0x6c, 0x9c, 0x86, 0xa2, 0x25, 0x74, 0x7b, 0x27, 0xe6,
	0xe4, 0x51, 0xbc, 0xfc, 0x57, 0x63, 0xcf, 0x28, 0x0c, 0xad, 0x49, 0xe0, 0x1d, 0x30, 0x15, 0x63,
	0x17, 0x87, 0xac, 0xa7, 0xd3, 0x38, 0x68, 0x7d, 0x38, 0xd9, 0x47, 0x8d, 0x41, 0xbb, 0x2a, 0x51,
	0x74, 0x0f, 0x6f, 0x80, 0xb9, 0x56, 0xca, 0xd2, 0x18, 0x2b, 0x58, 0x51, 0xd9, 0x89, 0x59, 0x14,
	0xd8, 0xc7, 0x97, 0xf6, 0xac, 0x74, 0x96, 0x68, 0x42, 0xc9, 0x07, 0xa4, 0x1b, 0x63, 0xc4, 0xd4,
	0x94, 0x1d, 0x1f, 0x75, 0x40, 0x4a, 0x27, 0x3d, 0x63, 0xd3, 0xc8, 0xcb, 0x20, 0x26, 0x46, 0x85,
	0x90, 0x4e, 0x02, 0xe2, 0x5d, 0x70, 0x92, 0x84, 0x7b, 0xc8, 0x27, 0x9e, 0x93, 0x4d, 0x7d, 0x1c,
	0xc7, 0x34, 0x36, 0x4b, 0xa2, 0x80, 0xe6, 0x95, 0x56, 0x73, 0xb4, 0xc6, 0x75, 0xb5, 0xef, 0x72,
	0xa0, 0xa4, 0x25, 0x70, 0x19, 0x14, 0x92, 0x08, 0xbb, 0xaa, 0x6f, 0xce, 0x1f, 0xcf, 0xb3, 0x78,
	0xe6, 0x08, 0x1f, 0xf8, 0xb1, 0xbe, 0x8f, 0xd4, 0x90, 0x58, 0x1c, 0x39, 0x4b, 0xca, 0x0f, 0x5e,
	0x07, 0xa5, 0x48, 0xbd, 0x09, 0x44, 0xa5, 0x95, 0x9b, 0x6f, 0x1e, 0x8f, 0xa1, 0x5f, 0x11, 0x76,
	0xe6, 0x0b, 0x3f, 0x00, 0xc5, 0x84, 0x5f, 0x02, 0xea, 0x81, 0x75, 0x61, 0x84, 0x30, 0xb8, 0xb9,
	0x2d, 0xbd, 0x6a, 0xcf, 0x73, 0x07, 0x6f, 0x94, 0x1b, 0x24, 0x61, 0xa2, 0xc7, 0x5e, 0x86, 0x99,
	0x75, 0x50, 0xcd, 0xae, 0x3d, 0xd6, 0x8d, 0xf4, 0x14, 0x3d, 0x77, 0x5c, 0x6f, 0x6c, 0x75, 0x23,
	0x6c, 0x57, 0x3a, 0x3d, 0xab, 0x83, 0x6b, 0x2d, 0x7f, 0xf4, 0xb5, 0x56, 0xe8, 0xbb, 0xd6, 0x06,
	0x1b, 0xa8, 0xf8, 0x0a, 0x1b, 0x68, 0xfc, 0x7f, 0x37, 0x50, 0xed, 0x6f, 0x03, 0xcc, 0xf6, 0x52,
	0xbe, 0x16, 0xb2, 0xb8, 0x0b, 0xcf, 0x82, 0x72, 0x56, 0xc8, 0x44, 0xff, 0x53, 0x01, 0x2d, 0x5a,
	0xf7, 0xe0, 0x3b, 0xa0, 0x10, 0xe0, 0x80, 0x2a, 0x3e, 0x5f, 0x1b, 0xc6, 0xe7, 0x4d, 0x1c, 0x50,
	0x5b, 0x58, 0xc2, 0x3b, 0x60, 0x36, 0xc1, 0x28, 0x76, 0x77, 0x1c, 0xc4, 0x58, 0x4c, 0xb6, 0x53,
	0x96, 0xd5, 0xda, 0xe2, 0x30, 0xf7, 0x4d, 0xe1, 0xb0, 0x92, 0xd9, 0xdb, 0x33, 0xc9, 0x21, 0x09,
	0xfc, 0x10, 0x14, 0x48, 0xd8, 0xa2, 0xaa, 0xe0, 0x46, 0xa8, 0x5a, 0x5d, 0x57, 0xb6, 0xf0, 0x5b,
	0x7d, 0x6a, 0x3c, 0x7c, 0x6c, 0x8d, 0x3d, 0x7a, 0x6c, 0x8d, 0x3d, 0x7f, 0x6c, 0x19, 0xdf, 0xec,
	0x5b, 0xc6, 0x8f, 0xfb, 0x96, 0xf1, 0xcb, 0xbe, 0x65, 0x3c, 0xdc, 0xb7, 0x8c, 0x3f, 0xf6, 0x2d,
	0xe3, 0xe9, 0xbe, 0x35, 0xf6, 0x7c, 0xdf, 0x32, 0x1e, 0x3c, 0xb1, 0xc6, 0x1e, 0x3e, 0xb1, 0xc6,
	0x1e, 0x3d, 0xb1, 0xc6, 0xc0, 0x19, 0x42, 0x87, 0x6e, 0xb5, 0x5a, 0xb9, 0x29, 0x7f, 0x56, 0x37,
	0x78, 0x1e, 0x36, 0x8c, 0xcf, 0x6e, 0xf4, 0xfc, 0x50, 0x6b, 0x27, 0x42, 0x1b, 0x29, 0xb9, 0x94,
	0xe0, 0x78, 0x0f, 0xc7, 0x8d, 0xbd, 0x66, 0x43, 0x7d, 0xb5, 0x71, 0x88, 0x63, 0xc4, 0xb0, 0x77,
	0xf8, 0xf7, 0xff, 0x8a, 0xfe, 0xfe, 0x29, 0x67, 0x6e, 0xe9, 0x8d, 0x57, 0x22, 0x92, 0xc5, 0x55,
	0xbf, 0xbb, 0xf4, 0x2c, 0x77, 0x46, 0xab, 0x96, 0x97, 0x57, 0x22, 0xb2, 0xbc, 0xac, 0x95, 0xcb,
	0xcb, 0x77, 0x97, 0xb6, 0xc7, 0x45, 0x5d, 0x5c, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xfb,
	0x0b, 0xcb, 0x63, 0x10, 0x00, 0x00,
}

func (this *CalendarSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalendarSpec)
	if !ok {
		that2, ok := that.(CalendarSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Second != that1.Second {
		return false
	}
	if this.Minute != that1.Minute {
		return false
	}
	if this.Hour != that1.Hour {
		return false
	}
	if this.DayOfMonth != that1.DayOfMonth {
		return false
	}
	if this.Month != that1.Month {
		return false
	}
	if this.Year != that1.Year {
		return false
	}
	if this.DayOfWeek != that1.DayOfWeek {
		return false
	}
	return true
}
func (this *IntervalSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntervalSpec)
	if !ok {
		that2, ok := that.(IntervalSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Interval != nil && that1.Interval != nil {
		if *this.Interval != *that1.Interval {
			return false
		}
	} else if this.Interval != nil {
		return false
	} else if that1.Interval != nil {
		return false
	}
	if this.Phase != nil && that1.Phase != nil {
		if *this.Phase != *that1.Phase {
			return false
		}
	} else if this.Phase != nil {
		return false
	} else if that1.Phase != nil {
		return false
	}
	return true
}
func (this *ScheduleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleSpec)
	if !ok {
		that2, ok := that.(ScheduleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Calendar) != len(that1.Calendar) {
		return false
	}
	for i := range this.Calendar {
		if !this.Calendar[i].Equal(that1.Calendar[i]) {
			return false
		}
	}
	if len(this.Interval) != len(that1.Interval) {
		return false
	}
	for i := range this.Interval {
		if !this.Interval[i].Equal(that1.Interval[i]) {
			return false
		}
	}
	if len(this.ExcludeCalendar) != len(that1.ExcludeCalendar) {
		return false
	}
	for i := range this.ExcludeCalendar {
		if !this.ExcludeCalendar[i].Equal(that1.ExcludeCalendar[i]) {
			return false
		}
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if this.Jitter != nil && that1.Jitter != nil {
		if *this.Jitter != *that1.Jitter {
			return false
		}
	} else if this.Jitter != nil {
		return false
	} else if that1.Jitter != nil {
		return false
	}
	if this.TimezoneName != that1.TimezoneName {
		return false
	}
	if !bytes.Equal(this.TimezoneData, that1.TimezoneData) {
		return false
	}
	return true
}
func (this *SchedulePolicies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchedulePolicies)
	if !ok {
		that2, ok := that.(SchedulePolicies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	if this.CatchupWindow != nil && that1.CatchupWindow != nil {
		if *this.CatchupWindow != *that1.CatchupWindow {
			return false
		}
	} else if this.CatchupWindow != nil {
		return false
	} else if that1.CatchupWindow != nil {
		return false
	}
	if this.PauseOnFailure != that1.PauseOnFailure {
		return false
	}
	return true
}
func (this *ScheduleAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleAction)
	if !ok {
		that2, ok := that.(ScheduleAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	return true
}
func (this *ScheduleAction_StartWorkflow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleAction_StartWorkflow)
	if !ok {
		that2, ok := that.(ScheduleAction_StartWorkflow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StartWorkflow.Equal(that1.StartWorkflow) {
		return false
	}
	return true
}
func (this *ScheduleActionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleActionResult)
	if !ok {
		that2, ok := that.(ScheduleActionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ScheduleTime == nil {
		if this.ScheduleTime != nil {
			return false
		}
	} else if !this.ScheduleTime.Equal(*that1.ScheduleTime) {
		return false
	}
	if that1.ActualTime == nil {
		if this.ActualTime != nil {
			return false
		}
	} else if !this.ActualTime.Equal(*that1.ActualTime) {
		return false
	}
	if !this.StartWorkflowResult.Equal(that1.StartWorkflowResult) {
		return false
	}
	return true
}
func (this *ScheduleState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleState)
	if !ok {
		that2, ok := that.(ScheduleState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	if this.Paused != that1.Paused {
		return false
	}
	if this.LimitedActions != that1.LimitedActions {
		return false
	}
	if this.RemainingActions != that1.RemainingActions {
		return false
	}
	return true
}
func (this *TriggerImmediatelyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TriggerImmediatelyRequest)
	if !ok {
		that2, ok := that.(TriggerImmediatelyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	return true
}
func (this *BackfillRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BackfillRequest)
	if !ok {
		that2, ok := that.(BackfillRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if this.OverlapPolicy != that1.OverlapPolicy {
		return false
	}
	return true
}
func (this *SchedulePatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchedulePatch)
	if !ok {
		that2, ok := that.(SchedulePatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TriggerImmediately.Equal(that1.TriggerImmediately) {
		return false
	}
	if len(this.BackfillRequest) != len(that1.BackfillRequest) {
		return false
	}
	for i := range this.BackfillRequest {
		if !this.BackfillRequest[i].Equal(that1.BackfillRequest[i]) {
			return false
		}
	}
	if this.Pause != that1.Pause {
		return false
	}
	if this.Unpause != that1.Unpause {
		return false
	}
	return true
}
func (this *ScheduleInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleInfo)
	if !ok {
		that2, ok := that.(ScheduleInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionCount != that1.ActionCount {
		return false
	}
	if this.MissedCatchupWindow != that1.MissedCatchupWindow {
		return false
	}
	if this.OverlapSkipped != that1.OverlapSkipped {
		return false
	}
	if len(this.RunningWorkflows) != len(that1.RunningWorkflows) {
		return false
	}
	for i := range this.RunningWorkflows {
		if !this.RunningWorkflows[i].Equal(that1.RunningWorkflows[i]) {
			return false
		}
	}
	if len(this.RecentActions) != len(that1.RecentActions) {
		return false
	}
	for i := range this.RecentActions {
		if !this.RecentActions[i].Equal(that1.RecentActions[i]) {
			return false
		}
	}
	if len(this.FutureActionTimes) != len(that1.FutureActionTimes) {
		return false
	}
	for i := range this.FutureActionTimes {
		if !this.FutureActionTimes[i].Equal(*that1.FutureActionTimes[i]) {
			return false
		}
	}
	if that1.CreateTime == nil {
		if this.CreateTime != nil {
			return false
		}
	} else if !this.CreateTime.Equal(*that1.CreateTime) {
		return false
	}
	if that1.UpdateTime == nil {
		if this.UpdateTime != nil {
			return false
		}
	} else if !this.UpdateTime.Equal(*that1.UpdateTime) {
		return false
	}
	if this.InvalidScheduleError != that1.InvalidScheduleError {
		return false
	}
	return true
}
func (this *Schedule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schedule)
	if !ok {
		that2, ok := that.(Schedule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if !this.Policies.Equal(that1.Policies) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *ScheduleListInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleListInfo)
	if !ok {
		that2, ok := that.(ScheduleListInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.WorkflowType.Equal(that1.WorkflowType) {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	if this.Paused != that1.Paused {
		return false
	}
	if len(this.RecentActions) != len(that1.RecentActions) {
		return false
	}
	for i := range this.RecentActions {
		if !this.RecentActions[i].Equal(that1.RecentActions[i]) {
			return false
		}
	}
	if len(this.FutureActionTimes) != len(that1.FutureActionTimes) {
		return false
	}
	for i := range this.FutureActionTimes {
		if !this.FutureActionTimes[i].Equal(*that1.FutureActionTimes[i]) {
			return false
		}
	}
	return true
}
func (this *ScheduleListEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScheduleListEntry)
	if !ok {
		that2, ok := that.(ScheduleListEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScheduleId != that1.ScheduleId {
		return false
	}
	if !this.Memo.Equal(that1.Memo) {
		return false
	}
	if !this.SearchAttributes.Equal(that1.SearchAttributes) {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *CalendarSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schedule.CalendarSpec{")
	s = append(s, "Second: "+fmt.Sprintf("%#v", this.Second)+",\n")
	s = append(s, "Minute: "+fmt.Sprintf("%#v", this.Minute)+",\n")
	s = append(s, "Hour: "+fmt.Sprintf("%#v", this.Hour)+",\n")
	s = append(s, "DayOfMonth: "+fmt.Sprintf("%#v", this.DayOfMonth)+",\n")
	s = append(s, "Month: "+fmt.Sprintf("%#v", this.Month)+",\n")
	s = append(s, "Year: "+fmt.Sprintf("%#v", this.Year)+",\n")
	s = append(s, "DayOfWeek: "+fmt.Sprintf("%#v", this.DayOfWeek)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntervalSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schedule.IntervalSpec{")
	s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&schedule.ScheduleSpec{")
	if this.Calendar != nil {
		s = append(s, "Calendar: "+fmt.Sprintf("%#v", this.Calendar)+",\n")
	}
	if this.Interval != nil {
		s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	}
	if this.ExcludeCalendar != nil {
		s = append(s, "ExcludeCalendar: "+fmt.Sprintf("%#v", this.ExcludeCalendar)+",\n")
	}
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Jitter: "+fmt.Sprintf("%#v", this.Jitter)+",\n")
	s = append(s, "TimezoneName: "+fmt.Sprintf("%#v", this.TimezoneName)+",\n")
	s = append(s, "TimezoneData: "+fmt.Sprintf("%#v", this.TimezoneData)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SchedulePolicies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.SchedulePolicies{")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "CatchupWindow: "+fmt.Sprintf("%#v", this.CatchupWindow)+",\n")
	s = append(s, "PauseOnFailure: "+fmt.Sprintf("%#v", this.PauseOnFailure)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schedule.ScheduleAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleAction_StartWorkflow) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schedule.ScheduleAction_StartWorkflow{` +
		`StartWorkflow:` + fmt.Sprintf("%#v", this.StartWorkflow) + `}`}, ", ")
	return s
}
func (this *ScheduleActionResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.ScheduleActionResult{")
	s = append(s, "ScheduleTime: "+fmt.Sprintf("%#v", this.ScheduleTime)+",\n")
	s = append(s, "ActualTime: "+fmt.Sprintf("%#v", this.ActualTime)+",\n")
	if this.StartWorkflowResult != nil {
		s = append(s, "StartWorkflowResult: "+fmt.Sprintf("%#v", this.StartWorkflowResult)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.ScheduleState{")
	s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	s = append(s, "Paused: "+fmt.Sprintf("%#v", this.Paused)+",\n")
	s = append(s, "LimitedActions: "+fmt.Sprintf("%#v", this.LimitedActions)+",\n")
	s = append(s, "RemainingActions: "+fmt.Sprintf("%#v", this.RemainingActions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TriggerImmediatelyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schedule.TriggerImmediatelyRequest{")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BackfillRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schedule.BackfillRequest{")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "OverlapPolicy: "+fmt.Sprintf("%#v", this.OverlapPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SchedulePatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.SchedulePatch{")
	if this.TriggerImmediately != nil {
		s = append(s, "TriggerImmediately: "+fmt.Sprintf("%#v", this.TriggerImmediately)+",\n")
	}
	if this.BackfillRequest != nil {
		s = append(s, "BackfillRequest: "+fmt.Sprintf("%#v", this.BackfillRequest)+",\n")
	}
	s = append(s, "Pause: "+fmt.Sprintf("%#v", this.Pause)+",\n")
	s = append(s, "Unpause: "+fmt.Sprintf("%#v", this.Unpause)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&schedule.ScheduleInfo{")
	s = append(s, "ActionCount: "+fmt.Sprintf("%#v", this.ActionCount)+",\n")
	s = append(s, "MissedCatchupWindow: "+fmt.Sprintf("%#v", this.MissedCatchupWindow)+",\n")
	s = append(s, "OverlapSkipped: "+fmt.Sprintf("%#v", this.OverlapSkipped)+",\n")
	if this.RunningWorkflows != nil {
		s = append(s, "RunningWorkflows: "+fmt.Sprintf("%#v", this.RunningWorkflows)+",\n")
	}
	if this.RecentActions != nil {
		s = append(s, "RecentActions: "+fmt.Sprintf("%#v", this.RecentActions)+",\n")
	}
	s = append(s, "FutureActionTimes: "+fmt.Sprintf("%#v", this.FutureActionTimes)+",\n")
	s = append(s, "CreateTime: "+fmt.Sprintf("%#v", this.CreateTime)+",\n")
	s = append(s, "UpdateTime: "+fmt.Sprintf("%#v", this.UpdateTime)+",\n")
	s = append(s, "InvalidScheduleError: "+fmt.Sprintf("%#v", this.InvalidScheduleError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Schedule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.Schedule{")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	if this.Policies != nil {
		s = append(s, "Policies: "+fmt.Sprintf("%#v", this.Policies)+",\n")
	}
	if this.State != nil {
		s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleListInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schedule.ScheduleListInfo{")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.WorkflowType != nil {
		s = append(s, "WorkflowType: "+fmt.Sprintf("%#v", this.WorkflowType)+",\n")
	}
	s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	s = append(s, "Paused: "+fmt.Sprintf("%#v", this.Paused)+",\n")
	if this.RecentActions != nil {
		s = append(s, "RecentActions: "+fmt.Sprintf("%#v", this.RecentActions)+",\n")
	}
	s = append(s, "FutureActionTimes: "+fmt.Sprintf("%#v", this.FutureActionTimes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScheduleListEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schedule.ScheduleListEntry{")
	s = append(s, "ScheduleId: "+fmt.Sprintf("%#v", this.ScheduleId)+",\n")
	if this.Memo != nil {
		s = append(s, "Memo: "+fmt.Sprintf("%#v", this.Memo)+",\n")
	}
	if this.SearchAttributes != nil {
		s = append(s, "SearchAttributes: "+fmt.Sprintf("%#v", this.SearchAttributes)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CalendarSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalendarSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalendarSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DayOfWeek) > 0 {
		i -= len(m.DayOfWeek)
		copy(dAtA[i:], m.DayOfWeek)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DayOfWeek)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Year) > 0 {
		i -= len(m.Year)
		copy(dAtA[i:], m.Year)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Year)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Month) > 0 {
		i -= len(m.Month)
		copy(dAtA[i:], m.Month)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Month)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DayOfMonth) > 0 {
		i -= len(m.DayOfMonth)
		copy(dAtA[i:], m.DayOfMonth)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DayOfMonth)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hour) > 0 {
		i -= len(m.Hour)
		copy(dAtA[i:], m.Hour)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Hour)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Minute) > 0 {
		i -= len(m.Minute)
		copy(dAtA[i:], m.Minute)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Minute)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Second) > 0 {
		i -= len(m.Second)
		copy(dAtA[i:], m.Second)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Second)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IntervalSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntervalSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Phase, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Phase):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintMessage(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x12
	}
	if m.Interval != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Interval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Interval):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintMessage(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimezoneData) > 0 {
		i -= len(m.TimezoneData)
		copy(dAtA[i:], m.TimezoneData)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TimezoneData)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TimezoneName) > 0 {
		i -= len(m.TimezoneName)
		copy(dAtA[i:], m.TimezoneName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TimezoneName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Jitter != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Jitter, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Jitter):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintMessage(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x32
	}
	if m.EndTime != nil {
		n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintMessage(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartTime != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintMessage(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExcludeCalendar) > 0 {
		for iNdEx := len(m.ExcludeCalendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeCalendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Interval) > 0 {
		for iNdEx := len(m.Interval) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interval[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Calendar) > 0 {
		for iNdEx := len(m.Calendar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Calendar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePolicies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePolicies) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePolicies) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PauseOnFailure {
		i--
		if m.PauseOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CatchupWindow != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.CatchupWindow, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CatchupWindow):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintMessage(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x12
	}
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction_StartWorkflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction_StartWorkflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartWorkflow != nil {
		{
			size, err := m.StartWorkflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ScheduleActionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleActionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleActionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartWorkflowResult != nil {
		{
			size, err := m.StartWorkflowResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ActualTime != nil {
		n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ActualTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ActualTime):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintMessage(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x12
	}
	if m.ScheduleTime != nil {
		n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ScheduleTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ScheduleTime):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintMessage(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemainingActions != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RemainingActions))
		i--
		dAtA[i] = 0x20
	}
	if m.LimitedActions {
		i--
		if m.LimitedActions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerImmediatelyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerImmediatelyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerImmediatelyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackfillRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.EndTime != nil {
		n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime):])
		if err11 != nil {
			return 0, err11
		}
		i -= n11
		i = encodeVarintMessage(dAtA, i, uint64(n11))
		i--
		dAtA[i] = 0x12
	}
	if m.StartTime != nil {
		n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintMessage(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unpause) > 0 {
		i -= len(m.Unpause)
		copy(dAtA[i:], m.Unpause)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Unpause)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Pause) > 0 {
		i -= len(m.Pause)
		copy(dAtA[i:], m.Pause)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Pause)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BackfillRequest) > 0 {
		for iNdEx := len(m.BackfillRequest) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BackfillRequest[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TriggerImmediately != nil {
		{
			size, err := m.TriggerImmediately.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunningWorkflows) > 0 {
		for iNdEx := len(m.RunningWorkflows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RunningWorkflows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InvalidScheduleError) > 0 {
		i -= len(m.InvalidScheduleError)
		copy(dAtA[i:], m.InvalidScheduleError)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.InvalidScheduleError)))
		i--
		dAtA[i] = 0x42
	}
	if m.UpdateTime != nil {
		n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdateTime):])
		if err14 != nil {
			return 0, err14
		}
		i -= n14
		i = encodeVarintMessage(dAtA, i, uint64(n14))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreateTime != nil {
		n15, err15 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreateTime):])
		if err15 != nil {
			return 0, err15
		}
		i -= n15
		i = encodeVarintMessage(dAtA, i, uint64(n15))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FutureActionTimes) > 0 {
		for iNdEx := len(m.FutureActionTimes) - 1; iNdEx >= 0; iNdEx-- {
			n, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.FutureActionTimes[iNdEx], dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.FutureActionTimes[iNdEx]):])
			if err != nil {
				return 0, err
			}
			i -= n
			i = encodeVarintMessage(dAtA, i, uint64(n))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RecentActions) > 0 {
		for iNdEx := len(m.RecentActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecentActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.OverlapSkipped != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OverlapSkipped))
		i--
		dAtA[i] = 0x18
	}
	if m.MissedCatchupWindow != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MissedCatchupWindow))
		i--
		dAtA[i] = 0x10
	}
	if m.ActionCount != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Policies != nil {
		{
			size, err := m.Policies.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleListInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleListInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FutureActionTimes) > 0 {
		for iNdEx := len(m.FutureActionTimes) - 1; iNdEx >= 0; iNdEx-- {
			n, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.FutureActionTimes[iNdEx], dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.FutureActionTimes[iNdEx]):])
			if err != nil {
				return 0, err
			}
			i -= n
			i = encodeVarintMessage(dAtA, i, uint64(n))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RecentActions) > 0 {
		for iNdEx := len(m.RecentActions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecentActions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WorkflowType != nil {
		{
			size, err := m.WorkflowType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleListEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleListEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleListEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SearchAttributes != nil {
		{
			size, err := m.SearchAttributes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Memo != nil {
		{
			size, err := m.Memo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScheduleId) > 0 {
		i -= len(m.ScheduleId)
		copy(dAtA[i:], m.ScheduleId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ScheduleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CalendarSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Second)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Minute)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Hour)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DayOfMonth)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Month)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Year)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DayOfWeek)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *IntervalSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Interval)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Phase != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Phase)
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Calendar) > 0 {
		for _, e := range m.Calendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Interval) > 0 {
		for _, e := range m.Interval {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.ExcludeCalendar) > 0 {
		for _, e := range m.ExcludeCalendar {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.StartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Jitter != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Jitter)
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.TimezoneName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.TimezoneData)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *SchedulePolicies) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	if m.CatchupWindow != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CatchupWindow)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.PauseOnFailure {
		n += 2
	}
	return n
}

func (m *ScheduleAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ScheduleAction_StartWorkflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartWorkflow != nil {
		l = m.StartWorkflow.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *ScheduleActionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScheduleTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ScheduleTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ActualTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ActualTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.StartWorkflowResult != nil {
		l = m.StartWorkflowResult.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if m.LimitedActions {
		n += 2
	}
	if m.RemainingActions != 0 {
		n += 1 + sovMessage(uint64(m.RemainingActions))
	}
	return n
}

func (m *TriggerImmediatelyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	return n
}

func (m *BackfillRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.OverlapPolicy != 0 {
		n += 1 + sovMessage(uint64(m.OverlapPolicy))
	}
	return n
}

func (m *SchedulePatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TriggerImmediately != nil {
		l = m.TriggerImmediately.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.BackfillRequest) > 0 {
		for _, e := range m.BackfillRequest {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Pause)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Unpause)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionCount != 0 {
		n += 1 + sovMessage(uint64(m.ActionCount))
	}
	if m.MissedCatchupWindow != 0 {
		n += 1 + sovMessage(uint64(m.MissedCatchupWindow))
	}
	if m.OverlapSkipped != 0 {
		n += 1 + sovMessage(uint64(m.OverlapSkipped))
	}
	if len(m.RecentActions) > 0 {
		for _, e := range m.RecentActions {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.FutureActionTimes) > 0 {
		for _, e := range m.FutureActionTimes {
			l = github_com_gogo_protobuf_types.SizeOfStdTime(*e)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.CreateTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreateTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UpdateTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdateTime)
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.InvalidScheduleError)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.RunningWorkflows) > 0 {
		for _, e := range m.RunningWorkflows {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Schedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Policies != nil {
		l = m.Policies.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ScheduleListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.WorkflowType != nil {
		l = m.WorkflowType.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if len(m.RecentActions) > 0 {
		for _, e := range m.RecentActions {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.FutureActionTimes) > 0 {
		for _, e := range m.FutureActionTimes {
			l = github_com_gogo_protobuf_types.SizeOfStdTime(*e)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *ScheduleListEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScheduleId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Memo != nil {
		l = m.Memo.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.SearchAttributes != nil {
		l = m.SearchAttributes.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CalendarSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CalendarSpec{`,
		`Second:` + fmt.Sprintf("%v", this.Second) + `,`,
		`Minute:` + fmt.Sprintf("%v", this.Minute) + `,`,
		`Hour:` + fmt.Sprintf("%v", this.Hour) + `,`,
		`DayOfMonth:` + fmt.Sprintf("%v", this.DayOfMonth) + `,`,
		`Month:` + fmt.Sprintf("%v", this.Month) + `,`,
		`Year:` + fmt.Sprintf("%v", this.Year) + `,`,
		`DayOfWeek:` + fmt.Sprintf("%v", this.DayOfWeek) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntervalSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntervalSpec{`,
		`Interval:` + strings.Replace(fmt.Sprintf("%v", this.Interval), "Duration", "types.Duration", 1) + `,`,
		`Phase:` + strings.Replace(fmt.Sprintf("%v", this.Phase), "Duration", "types.Duration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCalendar := "[]*CalendarSpec{"
	for _, f := range this.Calendar {
		repeatedStringForCalendar += strings.Replace(f.String(), "CalendarSpec", "CalendarSpec", 1) + ","
	}
	repeatedStringForCalendar += "}"
	repeatedStringForInterval := "[]*IntervalSpec{"
	for _, f := range this.Interval {
		repeatedStringForInterval += strings.Replace(f.String(), "IntervalSpec", "IntervalSpec", 1) + ","
	}
	repeatedStringForInterval += "}"
	repeatedStringForExcludeCalendar := "[]*CalendarSpec{"
	for _, f := range this.ExcludeCalendar {
		repeatedStringForExcludeCalendar += strings.Replace(f.String(), "CalendarSpec", "CalendarSpec", 1) + ","
	}
	repeatedStringForExcludeCalendar += "}"
	s := strings.Join([]string{`&ScheduleSpec{`,
		`Calendar:` + repeatedStringForCalendar + `,`,
		`Interval:` + repeatedStringForInterval + `,`,
		`ExcludeCalendar:` + repeatedStringForExcludeCalendar + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Jitter:` + strings.Replace(fmt.Sprintf("%v", this.Jitter), "Duration", "types.Duration", 1) + `,`,
		`TimezoneName:` + fmt.Sprintf("%v", this.TimezoneName) + `,`,
		`TimezoneData:` + fmt.Sprintf("%v", this.TimezoneData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SchedulePolicies) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SchedulePolicies{`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`CatchupWindow:` + strings.Replace(fmt.Sprintf("%v", this.CatchupWindow), "Duration", "types.Duration", 1) + `,`,
		`PauseOnFailure:` + fmt.Sprintf("%v", this.PauseOnFailure) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleAction{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleAction_StartWorkflow) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleAction_StartWorkflow{`,
		`StartWorkflow:` + strings.Replace(fmt.Sprintf("%v", this.StartWorkflow), "NewWorkflowExecutionInfo", "v11.NewWorkflowExecutionInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleActionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleActionResult{`,
		`ScheduleTime:` + strings.Replace(fmt.Sprintf("%v", this.ScheduleTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ActualTime:` + strings.Replace(fmt.Sprintf("%v", this.ActualTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`StartWorkflowResult:` + strings.Replace(fmt.Sprintf("%v", this.StartWorkflowResult), "WorkflowExecution", "v12.WorkflowExecution", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleState{`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`Paused:` + fmt.Sprintf("%v", this.Paused) + `,`,
		`LimitedActions:` + fmt.Sprintf("%v", this.LimitedActions) + `,`,
		`RemainingActions:` + fmt.Sprintf("%v", this.RemainingActions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerImmediatelyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerImmediatelyRequest{`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BackfillRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BackfillRequest{`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`OverlapPolicy:` + fmt.Sprintf("%v", this.OverlapPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SchedulePatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBackfillRequest := "[]*BackfillRequest{"
	for _, f := range this.BackfillRequest {
		repeatedStringForBackfillRequest += strings.Replace(f.String(), "BackfillRequest", "BackfillRequest", 1) + ","
	}
	repeatedStringForBackfillRequest += "}"
	s := strings.Join([]string{`&SchedulePatch{`,
		`TriggerImmediately:` + strings.Replace(this.TriggerImmediately.String(), "TriggerImmediatelyRequest", "TriggerImmediatelyRequest", 1) + `,`,
		`BackfillRequest:` + repeatedStringForBackfillRequest + `,`,
		`Pause:` + fmt.Sprintf("%v", this.Pause) + `,`,
		`Unpause:` + fmt.Sprintf("%v", this.Unpause) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecentActions := "[]*ScheduleActionResult{"
	for _, f := range this.RecentActions {
		repeatedStringForRecentActions += strings.Replace(f.String(), "ScheduleActionResult", "ScheduleActionResult", 1) + ","
	}
	repeatedStringForRecentActions += "}"
	repeatedStringForFutureActionTimes := "[]*Timestamp{"
	for _, f := range this.FutureActionTimes {
		repeatedStringForFutureActionTimes += strings.Replace(fmt.Sprintf("%v", f), "Timestamp", "types.Timestamp", 1) + ","
	}
	repeatedStringForFutureActionTimes += "}"
	repeatedStringForRunningWorkflows := "[]*WorkflowExecution{"
	for _, f := range this.RunningWorkflows {
		repeatedStringForRunningWorkflows += strings.Replace(fmt.Sprintf("%v", f), "WorkflowExecution", "v12.WorkflowExecution", 1) + ","
	}
	repeatedStringForRunningWorkflows += "}"
	s := strings.Join([]string{`&ScheduleInfo{`,
		`ActionCount:` + fmt.Sprintf("%v", this.ActionCount) + `,`,
		`MissedCatchupWindow:` + fmt.Sprintf("%v", this.MissedCatchupWindow) + `,`,
		`OverlapSkipped:` + fmt.Sprintf("%v", this.OverlapSkipped) + `,`,
		`RecentActions:` + repeatedStringForRecentActions + `,`,
		`FutureActionTimes:` + repeatedStringForFutureActionTimes + `,`,
		`CreateTime:` + strings.Replace(fmt.Sprintf("%v", this.CreateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.UpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`InvalidScheduleError:` + fmt.Sprintf("%v", this.InvalidScheduleError) + `,`,
		`RunningWorkflows:` + repeatedStringForRunningWorkflows + `,`,
		`}`,
	}, "")
	return s
}
func (this *Schedule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Schedule{`,
		`Spec:` + strings.Replace(this.Spec.String(), "ScheduleSpec", "ScheduleSpec", 1) + `,`,
		`Action:` + strings.Replace(this.Action.String(), "ScheduleAction", "ScheduleAction", 1) + `,`,
		`Policies:` + strings.Replace(this.Policies.String(), "SchedulePolicies", "SchedulePolicies", 1) + `,`,
		`State:` + strings.Replace(this.State.String(), "ScheduleState", "ScheduleState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleListInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecentActions := "[]*ScheduleActionResult{"
	for _, f := range this.RecentActions {
		repeatedStringForRecentActions += strings.Replace(f.String(), "ScheduleActionResult", "ScheduleActionResult", 1) + ","
	}
	repeatedStringForRecentActions += "}"
	repeatedStringForFutureActionTimes := "[]*Timestamp{"
	for _, f := range this.FutureActionTimes {
		repeatedStringForFutureActionTimes += strings.Replace(fmt.Sprintf("%v", f), "Timestamp", "types.Timestamp", 1) + ","
	}
	repeatedStringForFutureActionTimes += "}"
	s := strings.Join([]string{`&ScheduleListInfo{`,
		`Spec:` + strings.Replace(this.Spec.String(), "ScheduleSpec", "ScheduleSpec", 1) + `,`,
		`WorkflowType:` + strings.Replace(fmt.Sprintf("%v", this.WorkflowType), "WorkflowType", "v12.WorkflowType", 1) + `,`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`Paused:` + fmt.Sprintf("%v", this.Paused) + `,`,
		`RecentActions:` + repeatedStringForRecentActions + `,`,
		`FutureActionTimes:` + repeatedStringForFutureActionTimes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScheduleListEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScheduleListEntry{`,
		`ScheduleId:` + fmt.Sprintf("%v", this.ScheduleId) + `,`,
		`Memo:` + strings.Replace(fmt.Sprintf("%v", this.Memo), "Memo", "v12.Memo", 1) + `,`,
		`SearchAttributes:` + strings.Replace(fmt.Sprintf("%v", this.SearchAttributes), "SearchAttributes", "v12.SearchAttributes", 1) + `,`,
		`Info:` + strings.Replace(this.Info.String(), "ScheduleListInfo", "ScheduleListInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CalendarSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalendarSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalendarSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Second = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Minute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Month = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Year = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfWeek", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayOfWeek = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phase == nil {
				m.Phase = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Phase, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calendar = append(m.Calendar, &CalendarSpec{})
			if err := m.Calendar[len(m.Calendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = append(m.Interval, &IntervalSpec{})
			if err := m.Interval[len(m.Interval)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeCalendar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeCalendar = append(m.ExcludeCalendar, &CalendarSpec{})
			if err := m.ExcludeCalendar[len(m.ExcludeCalendar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jitter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jitter == nil {
				m.Jitter = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Jitter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimezoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimezoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimezoneData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimezoneData = append(m.TimezoneData[:0], dAtA[iNdEx:postIndex]...)
			if m.TimezoneData == nil {
				m.TimezoneData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePolicies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePolicies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePolicies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchupWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CatchupWindow == nil {
				m.CatchupWindow = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.CatchupWindow, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PauseOnFailure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWorkflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v11.NewWorkflowExecutionInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ScheduleAction_StartWorkflow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleActionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleActionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleActionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleTime == nil {
				m.ScheduleTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ScheduleTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActualTime == nil {
				m.ActualTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ActualTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWorkflowResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartWorkflowResult == nil {
				m.StartWorkflowResult = &v12.WorkflowExecution{}
			}
			if err := m.StartWorkflowResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitedActions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitedActions = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingActions", wireType)
			}
			m.RemainingActions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingActions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerImmediatelyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerImmediatelyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerImmediatelyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackfillRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= v1.ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerImmediately", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerImmediately == nil {
				m.TriggerImmediately = &TriggerImmediatelyRequest{}
			}
			if err := m.TriggerImmediately.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackfillRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackfillRequest = append(m.BackfillRequest, &BackfillRequest{})
			if err := m.BackfillRequest[len(m.BackfillRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unpause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unpause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCount", wireType)
			}
			m.ActionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedCatchupWindow", wireType)
			}
			m.MissedCatchupWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedCatchupWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapSkipped", wireType)
			}
			m.OverlapSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentActions = append(m.RecentActions, &ScheduleActionResult{})
			if err := m.RecentActions[len(m.RecentActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureActionTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FutureActionTimes = append(m.FutureActionTimes, new(time.Time))
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.FutureActionTimes[len(m.FutureActionTimes)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidScheduleError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvalidScheduleError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningWorkflows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningWorkflows = append(m.RunningWorkflows, &v12.WorkflowExecution{})
			if err := m.RunningWorkflows[len(m.RunningWorkflows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ScheduleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &ScheduleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policies == nil {
				m.Policies = &SchedulePolicies{}
			}
			if err := m.Policies.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ScheduleState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ScheduleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowType == nil {
				m.WorkflowType = &v12.WorkflowType{}
			}
			if err := m.WorkflowType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentActions = append(m.RecentActions, &ScheduleActionResult{})
			if err := m.RecentActions[len(m.RecentActions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureActionTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FutureActionTimes = append(m.FutureActionTimes, new(time.Time))
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.FutureActionTimes[len(m.FutureActionTimes)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleListEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleListEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleListEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScheduleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memo == nil {
				m.Memo = &v12.Memo{}
			}
			if err := m.Memo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchAttributes == nil {
				m.SearchAttributes = &v12.SearchAttributes{}
			}
			if err := m.SearchAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ScheduleListInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
