{
  "swagger": "2.0",
  "info": {
    "title": "temporal/api/workflowservice/v1/service.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "WorkflowService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/cluster": {
      "get": {
        "summary": "GetClusterInfo returns information about temporal cluster",
        "operationId": "WorkflowService_GetClusterInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetClusterInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces": {
      "get": {
        "summary": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "WorkflowService_ListNamespaces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "RegisterNamespace creates a new namespace which can be used as a container for all resources.",
        "description": "A Namespace is a top level entity within Temporal, and is used as a container for resources\nlike workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\nisolation for all resources within the namespace. All resources belongs to exactly one\nnamespace.",
        "operationId": "WorkflowService_RegisterNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceRequest"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}": {
      "get": {
        "summary": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "WorkflowService_DescribeNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.",
        "description": "Once the namespace is deprecated it cannot be used to start new workflow executions. Existing\nworkflow executions will continue to run on deprecated namespaces.\nDeprecated.",
        "operationId": "WorkflowService_DeprecateNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeprecateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "securityToken",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "put": {
        "summary": "UpdateNamespace is used to update the information and configuration of a registered\nnamespace.",
        "description": "(-- api-linter: core::0134::method-signature=disabled\n    aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)\n(-- api-linter: core::0134::response-message-name=disabled\n    aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)",
        "operationId": "WorkflowService_UpdateNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "updateInfo": {
                  "$ref": "#/definitions/v1UpdateNamespaceInfo"
                },
                "config": {
                  "$ref": "#/definitions/v1NamespaceConfig"
                },
                "replicationConfig": {
                  "$ref": "#/definitions/v1NamespaceReplicationConfig"
                },
                "securityToken": {
                  "type": "string"
                },
                "deleteBadBinary": {
                  "type": "string"
                },
                "promoteNamespace": {
                  "type": "boolean",
                  "description": "promote local namespace to global namespace. Ignored if namespace is already global namespace."
                }
              },
              "title": "(-- api-linter: core::0134::request-mask-required=disabled\n    aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)\n(-- api-linter: core::0134::request-resource-required=disabled\n    aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules": {
      "get": {
        "summary": "List all schedules in a namespace.",
        "operationId": "WorkflowService_ListSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSchedulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list schedules in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "description": "How many to return at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Token to get the next page of results.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Creates a new schedule.\n(-- api-linter: core::0133::method-signature=disabled\n    aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)\n(-- api-linter: core::0133::response-message-name=disabled\n    aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)\n(-- api-linter: core::0133::http-uri-parent=disabled\n    aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)",
        "operationId": "WorkflowService_CreateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace the schedule should be created in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "scheduleId": {
                  "type": "string",
                  "description": "The id of the new schedule."
                },
                "schedule": {
                  "$ref": "#/definitions/v1Schedule",
                  "description": "The schedule spec, policies, action, and initial state."
                },
                "initialPatch": {
                  "$ref": "#/definitions/v1SchedulePatch",
                  "description": "Optional initial patch (e.g. to run the action once immediately)."
                },
                "identity": {
                  "type": "string",
                  "description": "The identity of the client who initiated this request."
                },
                "requestId": {
                  "type": "string",
                  "description": "A unique identifier for this create request for idempotence. Typically UUIDv4."
                },
                "memo": {
                  "$ref": "#/definitions/v1Memo",
                  "description": "Memo and search attributes to attach to the schedule itself."
                },
                "searchAttributes": {
                  "$ref": "#/definitions/v1SearchAttributes"
                }
              },
              "title": "(-- api-linter: core::0133::request-parent-required=disabled\n    aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)\n(-- api-linter: core::0133::request-unknown-fields=disabled\n    aip.dev/not-precedent: CreateSchedule doesn't follow Google API format --)\n(-- api-linter: core::0133::request-resource-behavior=disabled\n    aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)\n(-- api-linter: core::0203::optional=disabled\n    aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "summary": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "WorkflowService_DescribeSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes a schedule, removing it from the system.\n(-- api-linter: core::0135::method-signature=disabled\n    aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)\n(-- api-linter: core::0135::response-message-name=disabled\n    aip.dev/not-precedent: DeleteSchedule doesn't follow Google API format --)",
        "operationId": "WorkflowService_DeleteSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Changes the configuration or state of an existing schedule.\n(-- api-linter: core::0134::response-message-name=disabled\n    aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)\n(-- api-linter: core::0134::method-signature=disabled\n    aip.dev/not-precedent: UpdateSchedule RPC doesn't follow Google API format. --)",
        "operationId": "WorkflowService_UpdateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "schedule": {
                  "$ref": "#/definitions/v1Schedule",
                  "description": "The new schedule. The four main fields of the schedule (spec, action,\npolicies, state) are replaced completely by the values in this message."
                },
                "conflictToken": {
                  "type": "string",
                  "format": "byte",
                  "description": "This can be the value of conflict_token from a DescribeScheduleResponse,\nwhich will cause this request to fail if the schedule has been modified\nbetween the Describe and this Update.\nIf missing, the schedule will be updated unconditionally."
                },
                "identity": {
                  "type": "string",
                  "description": "The identity of the client who initiated this request."
                },
                "requestId": {
                  "type": "string",
                  "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
                }
              },
              "title": "(-- api-linter: core::0134::request-mask-required=disabled\n    aip.dev/not-precedent: UpdateSchedule doesn't follow Google API format --)"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "patch": {
        "summary": "Makes a specific change to a schedule or triggers an immediate action.\n(-- api-linter: core::0134::synonyms=disabled\n    aip.dev/not-precedent: we have both patch and update. --)",
        "operationId": "WorkflowService_PatchSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PatchScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "patch": {
                  "$ref": "#/definitions/v1SchedulePatch"
                },
                "identity": {
                  "type": "string",
                  "description": "The identity of the client who initiated this request."
                },
                "requestId": {
                  "type": "string",
                  "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue.name}": {
      "get": {
        "summary": "DescribeTaskQueue returns information about the target task queue.",
        "operationId": "WorkflowService_DescribeTaskQueue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeTaskQueueResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.kind",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.\n\n - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history\n\nThe task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "default": "TASK_QUEUE_KIND_UNSPECIFIED"
          },
          {
            "name": "taskQueueType",
            "description": " - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY"
            ],
            "default": "TASK_QUEUE_TYPE_UNSPECIFIED"
          },
          {
            "name": "includeTaskQueueStatus",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows": {
      "get": {
        "summary": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "WorkflowService_ListWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/archived": {
      "get": {
        "summary": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "WorkflowService_ListArchivedWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListArchivedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/batch/describe": {
      "get": {
        "summary": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "WorkflowService_DescribeBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/batch/terminate": {
      "post": {
        "summary": "StartBatchOperation starts a new batch operation",
        "operationId": "WorkflowService_StartBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "visibilityQuery": {
                  "type": "string",
                  "title": "Visibility query defines the the group of workflow to do batch operation"
                },
                "jobId": {
                  "type": "string",
                  "title": "Job ID defines the unique ID for the batch job"
                },
                "reason": {
                  "type": "string",
                  "title": "Reason to perform the batch operation"
                },
                "terminationOperation": {
                  "$ref": "#/definitions/v1BatchOperationTermination"
                },
                "signalOperation": {
                  "$ref": "#/definitions/v1BatchOperationSignal"
                },
                "cancellationOperation": {
                  "$ref": "#/definitions/v1BatchOperationCancellation"
                },
                "deletionOperation": {
                  "$ref": "#/definitions/v1BatchOperationDeletion"
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/closed": {
      "get": {
        "summary": "ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.",
        "operationId": "WorkflowService_ListClosedWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListClosedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "startTimeFilter.earliestTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "startTimeFilter.latestTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "executionFilter.workflowId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "executionFilter.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "typeFilter.name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "statusFilter.status",
            "description": " - WORKFLOW_EXECUTION_STATUS_RUNNING: Value 1 is hardcoded in SQL persistence.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
              "WORKFLOW_EXECUTION_STATUS_RUNNING",
              "WORKFLOW_EXECUTION_STATUS_COMPLETED",
              "WORKFLOW_EXECUTION_STATUS_FAILED",
              "WORKFLOW_EXECUTION_STATUS_CANCELED",
              "WORKFLOW_EXECUTION_STATUS_TERMINATED",
              "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
              "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
            ],
            "default": "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/count": {
      "get": {
        "summary": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "WorkflowService_CountWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/open": {
      "get": {
        "summary": "ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.",
        "operationId": "WorkflowService_ListOpenWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListOpenWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "startTimeFilter.earliestTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "startTimeFilter.latestTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "executionFilter.workflowId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "executionFilter.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "typeFilter.name",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/runs/{execution.runId}": {
      "get": {
        "summary": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "WorkflowService_DescribeWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/runs/{execution.runId}/events": {
      "get": {
        "summary": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n`NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "WorkflowService_GetWorkflowExecutionHistory",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\nthese, it should be passed here to fetch the next page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "waitNewEvent",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\nthe `history_event_filter_type`, or a timeout is hit.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "historyEventFilterType",
            "description": "Filter returned events such that they match the specified filter type.\nDefault: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
              "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
              "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
            ],
            "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
          },
          {
            "name": "skipArchival",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/runs/{execution.runId}/events/reverse": {
      "get": {
        "summary": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \norder (starting from last event). Fails with`NotFound` if the specified workflow execution is \nunknown to the service.",
        "operationId": "WorkflowService_GetWorkflowExecutionHistoryReverse",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryReverseResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/runs/{execution.runId}/query": {
      "post": {
        "summary": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "WorkflowService_QueryWorkflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1QueryWorkflowResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "execution": {
                  "type": "object",
                  "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
                },
                "query": {
                  "$ref": "#/definitions/v1WorkflowQuery"
                },
                "queryRejectCondition": {
                  "$ref": "#/definitions/v1QueryRejectCondition",
                  "description": "QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.\nDefault: QUERY_REJECT_CONDITION_NONE."
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/runs/{workflowExecution.runId}/cancel": {
      "post": {
        "summary": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\na workflow execution.",
        "description": "This result in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\nworkflow history and a new workflow task created for the workflow. Fails with `NotFound` if\nthe workflow is already completed or doesn't exist.",
        "operationId": "WorkflowService_RequestCancelWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RequestCancelWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "workflowExecution": {
                  "type": "object",
                  "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
                },
                "identity": {
                  "type": "string",
                  "title": "The identity of the worker/client"
                },
                "requestId": {
                  "type": "string",
                  "title": "Used to de-dupe cancellation requests"
                },
                "firstExecutionRunId": {
                  "type": "string",
                  "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
                },
                "reason": {
                  "type": "string",
                  "title": "Reason for requesting the cancellation"
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/runs/{workflowExecution.runId}/reset": {
      "post": {
        "summary": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n`WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\nexecution instance.\nTODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "WorkflowService_ResetWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "workflowExecution": {
                  "type": "object",
                  "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
                },
                "reason": {
                  "type": "string"
                },
                "workflowTaskFinishEventId": {
                  "type": "string",
                  "format": "int64",
                  "description": "The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n`WORKFLOW_TASK_STARTED` event to reset to."
                },
                "requestId": {
                  "type": "string",
                  "title": "Used to de-dupe reset requests"
                },
                "resetReapplyType": {
                  "$ref": "#/definitions/v1ResetReapplyType",
                  "description": "Reset reapplay(replay) options."
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/runs/{workflowExecution.runId}/signal": {
      "post": {
        "summary": "SignalWorkflowExecution is used to send a signal to a running workflow execution.",
        "description": "This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\ntask being created for the execution.",
        "operationId": "WorkflowService_SignalWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "workflowExecution": {
                  "type": "object",
                  "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
                },
                "signalName": {
                  "type": "string",
                  "title": "The workflow author-defined name of the signal to send to the workflow"
                },
                "input": {
                  "$ref": "#/definitions/v1Payloads",
                  "title": "Serialized value(s) to provide with the signal"
                },
                "identity": {
                  "type": "string",
                  "title": "The identity of the worker/client"
                },
                "requestId": {
                  "type": "string",
                  "title": "Used to de-dupe sent signals"
                },
                "control": {
                  "type": "string",
                  "title": "Deprecated"
                },
                "header": {
                  "$ref": "#/definitions/v1Header",
                  "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/runs/{workflowExecution.runId}/terminate": {
      "post": {
        "summary": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n`WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\nexecution instance.",
        "operationId": "WorkflowService_TerminateWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TerminateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.runId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "workflowExecution": {
                  "type": "object",
                  "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
                },
                "reason": {
                  "type": "string"
                },
                "details": {
                  "$ref": "#/definitions/v1Payloads",
                  "title": "Serialized additional information to attach to the termination event"
                },
                "identity": {
                  "type": "string",
                  "title": "The identity of the worker/client"
                },
                "firstExecutionRunId": {
                  "type": "string",
                  "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}/start": {
      "post": {
        "summary": "StartWorkflowExecution starts a new workflow execution.",
        "description": "It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\nalso schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\ninstance already exists with same workflow id.",
        "operationId": "WorkflowService_StartWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "workflowType": {
                  "$ref": "#/definitions/v1WorkflowType"
                },
                "taskQueue": {
                  "$ref": "#/definitions/v1TaskQueue"
                },
                "input": {
                  "$ref": "#/definitions/v1Payloads",
                  "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
                },
                "workflowExecutionTimeout": {
                  "type": "string",
                  "description": "Total workflow execution timeout including retries and continue as new."
                },
                "workflowRunTimeout": {
                  "type": "string",
                  "description": "Timeout of a single workflow run."
                },
                "workflowTaskTimeout": {
                  "type": "string",
                  "description": "Timeout of a single workflow task."
                },
                "identity": {
                  "type": "string",
                  "title": "The identity of the client who initiated this request"
                },
                "requestId": {
                  "type": "string",
                  "description": "A unique identifier for this start request. Typically UUIDv4."
                },
                "workflowIdReusePolicy": {
                  "$ref": "#/definitions/v1WorkflowIdReusePolicy",
                  "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
                },
                "retryPolicy": {
                  "$ref": "#/definitions/v1RetryPolicy",
                  "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
                },
                "cronSchedule": {
                  "type": "string",
                  "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
                },
                "memo": {
                  "$ref": "#/definitions/v1Memo"
                },
                "searchAttributes": {
                  "$ref": "#/definitions/v1SearchAttributes"
                },
                "header": {
                  "$ref": "#/definitions/v1Header"
                }
              }
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/search-attributes": {
      "get": {
        "summary": "GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs",
        "operationId": "WorkflowService_GetSearchAttributes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetSearchAttributesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    }
  },
  "definitions": {
    "GetSystemInfoResponseCapabilities": {
      "type": "object",
      "properties": {
        "signalAndQueryHeader": {
          "type": "boolean",
          "description": "True if signal and query headers are supported."
        },
        "internalErrorDifferentiation": {
          "type": "boolean",
          "description": "True if internal errors are differentiated from other types of errors for purposes of\nretrying non-internal errors.\n\nWhen unset/false, clients retry all failures. When true, clients should only retry\nnon-internal errors."
        },
        "activityFailureIncludeHeartbeat": {
          "type": "boolean",
          "title": "True if RespondActivityTaskFailed API supports including heartbeat details"
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Supports scheduled workflow features."
        },
        "encodedFailureAttributes": {
          "type": "boolean",
          "title": "True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes"
        },
        "buildIdBasedVersioning": {
          "type": "boolean",
          "title": "True if server supports dispatching Workflow and Activity tasks based on a worker's build_id\n(see:\nhttps://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)"
        },
        "upsertMemo": {
          "type": "boolean",
          "title": "True if server supports upserting workflow memo"
        }
      },
      "description": "System capability details."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1AcceptWorkflowUpdateCommandAttributes": {
      "type": "object",
      "properties": {
        "updateId": {
          "type": "string",
          "title": "A unique identifier for an update within a given workflow context"
        }
      }
    },
    "v1ActivityFailureInfo": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "identity": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to."
        },
        "newRetryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "If set, update the retry policy of the activity, replacing it with the specified one.\nThe number of attempts at the activity is preserved."
        }
      }
    },
    "v1ActivityTaskCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1ActivityTaskCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional information that the activity reported upon confirming cancellation"
        },
        "latestCancelRequestedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same\nactivity"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker who canceled this activity"
        }
      }
    },
    "v1ActivityTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized results of the activity. IE: The return value of the activity function"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that completed this task"
        }
      }
    },
    "v1ActivityTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "title": "Failure details"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that failed this task"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string",
          "title": "The worker/user assigned identifier for the activity"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\nretries will be attempted. Either this or `start_to_close_timeout` must be specified.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\ntimeout is always non retryable, as all a retry would achieve is to put it back into the same\nqueue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\nspecified.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be\nspecified.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are assigned a default retry policy controlled by the service's dynamic\nconfiguration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set\nretry_policy.maximum_attempts to 1."
        }
      }
    },
    "v1ActivityTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO ??"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times this task has been attempted"
        },
        "lastFailure": {
          "$ref": "#/definitions/v1Failure",
          "description": "Will be set to the most recent failure details, if this task has previously failed and then\nbeen retried."
        }
      }
    },
    "v1ActivityTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "description": "If this activity had failed, was retried, and then timed out, that failure is stored as the\n`cause` in here."
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a activity author to define the activity. Typically, the\nname of a function. This is sometimes referred to as the activity's \"name\""
    },
    "v1Alert": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "severity": {
          "$ref": "#/definitions/v1Severity"
        }
      },
      "description": "Alert contains notification and severity."
    },
    "v1ApplicationFailureInfo": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "nonRetryable": {
          "type": "boolean"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ArchivalState": {
      "type": "string",
      "enum": [
        "ARCHIVAL_STATE_UNSPECIFIED",
        "ARCHIVAL_STATE_DISABLED",
        "ARCHIVAL_STATE_ENABLED"
      ],
      "default": "ARCHIVAL_STATE_UNSPECIFIED"
    },
    "v1BackfillRequest": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time range to evaluate schedule in."
        },
        "endTime": {
          "type": "string",
          "format": "date-time"
        },
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "Override overlap policy for this request."
        }
      }
    },
    "v1BadBinaries": {
      "type": "object",
      "properties": {
        "binaries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1BadBinaryInfo"
          }
        }
      }
    },
    "v1BadBinaryInfo": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string"
        },
        "operator": {
          "type": "string"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1BatchOperationCancellation": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationCancellation sends cancel requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationDeletion": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationDeletion sends deletion requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest."
    },
    "v1BatchOperationSignal": {
      "type": "object",
      "properties": {
        "signal": {
          "type": "string",
          "title": "The workflow author-defined name of the signal to send to the workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationSignal sends signals to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest."
    },
    "v1BatchOperationState": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_STATE_UNSPECIFIED",
        "BATCH_OPERATION_STATE_RUNNING",
        "BATCH_OPERATION_STATE_COMPLETED",
        "BATCH_OPERATION_STATE_FAILED"
      ],
      "default": "BATCH_OPERATION_STATE_UNSPECIFIED"
    },
    "v1BatchOperationTermination": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide to the termination event"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationTermination sends terminate requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationType": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_TYPE_UNSPECIFIED",
        "BATCH_OPERATION_TYPE_TERMINATE",
        "BATCH_OPERATION_TYPE_CANCEL",
        "BATCH_OPERATION_TYPE_SIGNAL",
        "BATCH_OPERATION_TYPE_DELETE"
      ],
      "default": "BATCH_OPERATION_TYPE_UNSPECIFIED"
    },
    "v1CalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "string",
          "title": "Expression to match seconds. Default: 0"
        },
        "minute": {
          "type": "string",
          "title": "Expression to match minutes. Default: 0"
        },
        "hour": {
          "type": "string",
          "title": "Expression to match hours. Default: 0"
        },
        "dayOfMonth": {
          "type": "string",
          "title": "Expression to match days of the month. Default: *\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: standard name of field --)"
        },
        "month": {
          "type": "string",
          "title": "Expression to match months. Default: *"
        },
        "year": {
          "type": "string",
          "title": "Expression to match years. Default: *"
        },
        "dayOfWeek": {
          "type": "string",
          "title": "Expression to match days of the week. Default: *"
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "description": "CalendarSpec describes an event specification relative to the calendar,\nsimilar to a traditional cron specification, but with labeled fields. Each\nfield can be one of:\n  *: matches always\n  x: matches when the field equals x\n  x/y : matches when the field equals x+n*y where n is an integer\n  x-z: matches when the field is between x and z inclusive\n  w,x,y,...: matches when the field is one of the listed values\nEach x, y, z, ... is either a decimal integer, or a month or day of week name\nor abbreviation (in the appropriate fields).\nA timestamp matches if all fields match.\nNote that fields have different default values, for convenience.\nNote that the special case that some cron implementations have for treating\nday_of_month and day_of_week as \"or\" instead of \"and\" when both are set is\nnot implemented.\nday_of_week can accept 0 or 7 as Sunday\nCalendarSpec gets compiled into StructuredCalendarSpec, which is what will be\nreturned if you describe the schedule."
    },
    "v1CancelExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1CancelTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The same timer id from the start timer command"
        }
      }
    },
    "v1CancelWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1CanceledFailureInfo": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ChildWorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/v1Failure"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionFailureInfo": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1ChildWorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ClusterReplicationConfig": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string"
        }
      }
    },
    "v1Command": {
      "type": "object",
      "properties": {
        "commandType": {
          "$ref": "#/definitions/v1CommandType"
        },
        "scheduleActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1ScheduleActivityTaskCommandAttributes"
        },
        "startTimerCommandAttributes": {
          "$ref": "#/definitions/v1StartTimerCommandAttributes"
        },
        "completeWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CompleteWorkflowExecutionCommandAttributes"
        },
        "failWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1FailWorkflowExecutionCommandAttributes"
        },
        "requestCancelActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelActivityTaskCommandAttributes"
        },
        "cancelTimerCommandAttributes": {
          "$ref": "#/definitions/v1CancelTimerCommandAttributes"
        },
        "cancelWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CancelWorkflowExecutionCommandAttributes"
        },
        "requestCancelExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionCommandAttributes"
        },
        "recordMarkerCommandAttributes": {
          "$ref": "#/definitions/v1RecordMarkerCommandAttributes"
        },
        "continueAsNewWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1ContinueAsNewWorkflowExecutionCommandAttributes"
        },
        "startChildWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionCommandAttributes"
        },
        "signalExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionCommandAttributes"
        },
        "upsertWorkflowSearchAttributesCommandAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesCommandAttributes"
        },
        "acceptWorkflowUpdateCommandAttributes": {
          "$ref": "#/definitions/v1AcceptWorkflowUpdateCommandAttributes"
        },
        "completeWorkflowUpdateCommandAttributes": {
          "$ref": "#/definitions/v1CompleteWorkflowUpdateCommandAttributes"
        },
        "modifyWorkflowPropertiesCommandAttributes": {
          "$ref": "#/definitions/v1ModifyWorkflowPropertiesCommandAttributes"
        }
      }
    },
    "v1CommandType": {
      "type": "string",
      "enum": [
        "COMMAND_TYPE_UNSPECIFIED",
        "COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK",
        "COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK",
        "COMMAND_TYPE_START_TIMER",
        "COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_CANCEL_TIMER",
        "COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_RECORD_MARKER",
        "COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "COMMAND_TYPE_ACCEPT_WORKFLOW_UPDATE",
        "COMMAND_TYPE_COMPLETE_WORKFLOW_UPDATE",
        "COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES"
      ],
      "default": "COMMAND_TYPE_UNSPECIFIED",
      "description": "Whenever this list of command types is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering.\n\n - COMMAND_TYPE_ACCEPT_WORKFLOW_UPDATE: Indicates that an update has been accepted for processing workflow code\n - COMMAND_TYPE_COMPLETE_WORKFLOW_UPDATE: Indicates that an update has completed and carries either the success or\nfailure outcome of said update."
    },
    "v1CompleteWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1CompleteWorkflowUpdateCommandAttributes": {
      "type": "object",
      "properties": {
        "updateId": {
          "type": "string",
          "title": "A unique identifier for an update within a given workflow context"
        },
        "durabilityPreference": {
          "$ref": "#/definitions/v1WorkflowUpdateDurabilityPreference",
          "description": "Whether the server should attempt to bypass making this update rejection\ndurable in history. This field is only consulted when the result field\nindicates failure. Leaving this field in its default state (i.e.\nUPDATE_WORKFLOW_REJECTION_DURABILITY_PREFERENCE_UNSPECIFIED) will result\nin making the rejection durable."
        },
        "success": {
          "$ref": "#/definitions/v1Payloads"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure"
        }
      }
    },
    "v1ContinueAsNewInitiator": {
      "type": "string",
      "enum": [
        "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
        "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
        "CONTINUE_AS_NEW_INITIATOR_RETRY",
        "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE"
      ],
      "default": "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
      "title": "- CONTINUE_AS_NEW_INITIATOR_WORKFLOW: The workflow itself requested to continue as new\n - CONTINUE_AS_NEW_INITIATOR_RETRY: The workflow continued as new because it is retrying\n - CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE: The workflow continued as new because cron has triggered a new execution"
    },
    "v1ContinueAsNewWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "backoffStartInterval": {
          "type": "string",
          "description": "How long the workflow start will be delayed - not really a \"backoff\" in the traditional sense."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator",
          "title": "Should be removed"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "title": "Should be removed"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Should be removed"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Should be removed. Not necessarily unused but unclear and not exposed by SDKs."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1CountWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1CreateScheduleResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1DataBlob": {
      "type": "object",
      "properties": {
        "encodingType": {
          "$ref": "#/definitions/v1EncodingType"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1DeleteScheduleResponse": {
      "type": "object"
    },
    "v1DeprecateNamespaceResponse": {
      "type": "object",
      "description": "Deprecated."
    },
    "v1DescribeBatchOperationResponse": {
      "type": "object",
      "properties": {
        "operationType": {
          "$ref": "#/definitions/v1BatchOperationType",
          "title": "Batch operation type"
        },
        "jobId": {
          "type": "string",
          "title": "Batch job ID"
        },
        "state": {
          "$ref": "#/definitions/v1BatchOperationState",
          "title": "Batch operation state"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation start time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation close time"
        },
        "totalOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Total operation count"
        },
        "completeOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Complete operation count"
        },
        "failureOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Failure operation count"
        },
        "identity": {
          "type": "string",
          "title": "Identity indicates the operator identity"
        },
        "reason": {
          "type": "string",
          "title": "Reason indicates the reason to stop a operation"
        }
      }
    },
    "v1DescribeNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "failoverHistory": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1FailoverStatus"
          },
          "description": "Contains the historical state of failover_versions for the cluster, truncated to contain only the last N\nstates to ensure that the list does not grow unbounded."
        }
      }
    },
    "v1DescribeScheduleResponse": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "title": "The complete current schedule details. This may not match the schedule as\ncreated because:\n- some types of schedule specs may get compiled into others (e.g.\n  CronString into StructuredCalendarSpec)\n- some unspecified fields may be replaced by defaults\n- some fields in the state are modified automatically\n- the schedule may have been modified by UpdateSchedule or PatchSchedule"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleInfo",
          "description": "Extra schedule state info."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo",
          "description": "The memo and search attributes that the schedule was created with."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateSchedule to ensure that the\nschedule was not modified between a Describe and an Update, which could\nlead to lost updates and other confusion."
        }
      }
    },
    "v1DescribeTaskQueueResponse": {
      "type": "object",
      "properties": {
        "pollers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PollerInfo"
          }
        },
        "taskQueueStatus": {
          "$ref": "#/definitions/v1TaskQueueStatus"
        }
      }
    },
    "v1DescribeWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "executionConfig": {
          "$ref": "#/definitions/v1WorkflowExecutionConfig"
        },
        "workflowExecutionInfo": {
          "$ref": "#/definitions/v1WorkflowExecutionInfo"
        },
        "pendingActivities": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PendingActivityInfo"
          }
        },
        "pendingChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PendingChildExecutionInfo"
          }
        },
        "pendingWorkflowTask": {
          "$ref": "#/definitions/v1PendingWorkflowTaskInfo"
        }
      }
    },
    "v1EncodingType": {
      "type": "string",
      "enum": [
        "ENCODING_TYPE_UNSPECIFIED",
        "ENCODING_TYPE_PROTO3",
        "ENCODING_TYPE_JSON"
      ],
      "default": "ENCODING_TYPE_UNSPECIFIED"
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
        "EVENT_TYPE_WORKFLOW_TASK_STARTED",
        "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
        "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
        "EVENT_TYPE_ACTIVITY_TASK_STARTED",
        "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
        "EVENT_TYPE_ACTIVITY_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
        "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
        "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
        "EVENT_TYPE_TIMER_STARTED",
        "EVENT_TYPE_TIMER_FIRED",
        "EVENT_TYPE_TIMER_CANCELED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_MARKER_RECORDED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "EVENT_TYPE_WORKFLOW_UPDATE_REQUESTED",
        "EVENT_TYPE_WORKFLOW_UPDATE_ACCEPTED",
        "EVENT_TYPE_WORKFLOW_UPDATE_COMPLETED",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": "- EVENT_TYPE_UNSPECIFIED: Place holder and should never appear in a Workflow execution history\n - EVENT_TYPE_WORKFLOW_EXECUTION_STARTED: Workflow execution has been triggered/started\nIt contains Workflow execution inputs, as well as Workflow timeout configurations\n - EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED: Workflow execution has successfully completed and contains Workflow execution results\n - EVENT_TYPE_WORKFLOW_EXECUTION_FAILED: Workflow execution has unsuccessfully completed and contains the Workflow execution error\n - EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT: Workflow execution has timed out by the Temporal Server\nUsually due to the Workflow having not been completed within timeout settings\n - EVENT_TYPE_WORKFLOW_TASK_SCHEDULED: Workflow Task has been scheduled and the SDK client should now be able to process any new history events\n - EVENT_TYPE_WORKFLOW_TASK_STARTED: Workflow Task has started and the SDK client has picked up the Workflow Task and is processing new history events\n - EVENT_TYPE_WORKFLOW_TASK_COMPLETED: Workflow Task has completed\nThe SDK client picked up the Workflow Task and processed new history events\nSDK client may or may not ask the Temporal Server to do additional work, such as:\nEVENT_TYPE_ACTIVITY_TASK_SCHEDULED\nEVENT_TYPE_TIMER_STARTED\nEVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES\nEVENT_TYPE_MARKER_RECORDED\nEVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED\nEVENT_TYPE_WORKFLOW_EXECUTION_FAILED\nEVENT_TYPE_WORKFLOW_EXECUTION_CANCELED\nEVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW\n - EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT: Workflow Task encountered a timeout\nEither an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the task\n - EVENT_TYPE_WORKFLOW_TASK_FAILED: Workflow Task encountered a failure\nUsually this means that the Workflow was non-deterministic\nHowever, the Workflow reset functionality also uses this event\n - EVENT_TYPE_ACTIVITY_TASK_SCHEDULED: Activity Task was scheduled\nThe SDK client should pick up this activity task and execute\nThis event type contains activity inputs, as well as activity timeout configurations\n - EVENT_TYPE_ACTIVITY_TASK_STARTED: Activity Task has started executing\nThe SDK client has picked up the Activity Task and is processing the Activity invocation\n - EVENT_TYPE_ACTIVITY_TASK_COMPLETED: Activity Task has finished successfully\nThe SDK client has picked up and successfully completed the Activity Task\nThis event type contains Activity execution results\n - EVENT_TYPE_ACTIVITY_TASK_FAILED: Activity Task has finished unsuccessfully\nThe SDK picked up the Activity Task but unsuccessfully completed it\nThis event type contains Activity execution errors\n - EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT: Activity has timed out according to the Temporal Server\nActivity did not complete within the timeout settings\n - EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED: A request to cancel the Activity has occurred\nThe SDK client will be able to confirm cancellation of an Activity during an Activity heartbeat\n - EVENT_TYPE_ACTIVITY_TASK_CANCELED: Activity has been cancelled\n - EVENT_TYPE_TIMER_STARTED: A timer has started\n - EVENT_TYPE_TIMER_FIRED: A timer has fired\n - EVENT_TYPE_TIMER_CANCELED: A time has been cancelled\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED: A request has been made to cancel the Workflow execution\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED: SDK client has confirmed the cancellation request and the Workflow execution has been cancelled\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Workflow has requested that the Temporal Server try to cancel another Workflow\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server could not cancel the targeted Workflow\nThis is usually because the target Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED: Temporal Server has successfully requested the cancellation of the target Workflow\n - EVENT_TYPE_MARKER_RECORDED: A marker has been recorded.\nThis event type is transparent to the Temporal Server\nThe Server will only store it and will not try to understand it.\n - EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED: Workflow has received a Signal event\nThe event type contains the Signal name, as well as a Signal payload\n - EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED: Workflow execution has been forcefully terminated\nThis is usually because the terminate Workflow API was called\n - EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW: Workflow has successfully completed and a new Workflow has been started within the same transaction\nContains last Workflow execution results as well as new Workflow execution inputs\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to start a child Workflow\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution cannot be started/triggered\nUsually due to a child Workflow ID collision\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED: Child Workflow execution has successfully started/triggered\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED: Child Workflow execution has successfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution has unsuccessfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED: Child Workflow execution has been cancelled\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT: Child Workflow execution has timed out by the Temporal Server\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED: Child Workflow execution has been terminated\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to Signal the targeted Workflow\nContains the Signal name, as well as a Signal payload\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server cannot Signal the targeted Workflow\nUsually because the Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED: Temporal Server has successfully Signaled the targeted Workflow\n - EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: Workflow search attributes should be updated and synchronized with the visibility store\n - EVENT_TYPE_WORKFLOW_UPDATE_REQUESTED: Workflow update request has been received\n - EVENT_TYPE_WORKFLOW_UPDATE_ACCEPTED: Workflow update request has been accepted by user workflow code\n - EVENT_TYPE_WORKFLOW_UPDATE_COMPLETED: Workflow update has been completed\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of the workflow as a whole have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of an already-scheduled activity have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED: Workflow properties modified by user workflow code",
      "title": "Whenever this list of events is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering"
    },
    "v1ExternalWorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds\nto"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-cancelled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        }
      }
    },
    "v1ExternalWorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which was signaled.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1FailWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/v1Failure"
        }
      }
    },
    "v1FailoverStatus": {
      "type": "object",
      "properties": {
        "failoverTime": {
          "type": "string",
          "format": "date-time",
          "title": "Timestamp when the Cluster switched to the following failover_version"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "Represents a historical replication status of a Namespace"
    },
    "v1Failure": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "source": {
          "type": "string",
          "description": "The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK\nIn some SDKs this is used to rehydrate the stack trace into an exception object."
        },
        "stackTrace": {
          "type": "string"
        },
        "encodedAttributes": {
          "$ref": "#/definitions/v1Payload",
          "description": "Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of\nerrors originating in user code which might contain sensitive information.\nThe `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto\nmessage.\n\nSDK authors: \n- The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:\n  - Uses a JSON object to represent `{ message, stack_trace }`.\n  - Overwrites the original message with \"Encoded failure\" to indicate that more information could be extracted.\n  - Overwrites the original stack_trace with an empty string.\n  - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed\n    by the user-provided PayloadCodec\n\n- If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.\n(-- api-linter: core::0203::optional=disabled --)"
        },
        "cause": {
          "$ref": "#/definitions/v1Failure"
        },
        "applicationFailureInfo": {
          "$ref": "#/definitions/v1ApplicationFailureInfo"
        },
        "timeoutFailureInfo": {
          "$ref": "#/definitions/v1TimeoutFailureInfo"
        },
        "canceledFailureInfo": {
          "$ref": "#/definitions/v1CanceledFailureInfo"
        },
        "terminatedFailureInfo": {
          "$ref": "#/definitions/v1TerminatedFailureInfo"
        },
        "serverFailureInfo": {
          "$ref": "#/definitions/v1ServerFailureInfo"
        },
        "resetWorkflowFailureInfo": {
          "$ref": "#/definitions/v1ResetWorkflowFailureInfo"
        },
        "activityFailureInfo": {
          "$ref": "#/definitions/v1ActivityFailureInfo"
        },
        "childWorkflowExecutionFailureInfo": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailureInfo"
        }
      }
    },
    "v1GetClusterInfoResponse": {
      "type": "object",
      "properties": {
        "supportedClients": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Key is client name i.e \"temporal-go\", \"temporal-java\", or \"temporal-cli\".\nValue is ranges of supported versions of this client i.e \"\u003e1.1.1 \u003c=1.4.0 || ^5.0.0\"."
        },
        "serverVersion": {
          "type": "string"
        },
        "clusterId": {
          "type": "string"
        },
        "versionInfo": {
          "$ref": "#/definitions/v1VersionInfo"
        },
        "clusterName": {
          "type": "string"
        },
        "historyShardCount": {
          "type": "integer",
          "format": "int32"
        },
        "persistenceStore": {
          "type": "string"
        },
        "visibilityStore": {
          "type": "string"
        }
      },
      "description": "GetClusterInfoResponse contains information about Temporal cluster."
    },
    "v1GetSearchAttributesResponse": {
      "type": "object",
      "properties": {
        "keys": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          }
        }
      }
    },
    "v1GetSystemInfoResponse": {
      "type": "object",
      "properties": {
        "serverVersion": {
          "type": "string",
          "description": "Version of the server."
        },
        "capabilities": {
          "$ref": "#/definitions/GetSystemInfoResponseCapabilities",
          "description": "All capabilities the system supports."
        }
      }
    },
    "v1GetWorkflowExecutionHistoryResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "rawHistory": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1DataBlob"
          },
          "description": "Raw history is an alternate representation of history that may be returned if configured on\nthe frontend. This is not supported by all SDKs. Either this or `history` will be set."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        },
        "archived": {
          "type": "boolean"
        }
      }
    },
    "v1GetWorkflowExecutionHistoryReverseResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        }
      }
    },
    "v1Header": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "Contains metadata that can be attached to a variety of requests, like starting a workflow, and\ncan be propagated between, for example, workflows and activities."
    },
    "v1History": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1HistoryEvent"
          }
        }
      }
    },
    "v1HistoryEvent": {
      "type": "object",
      "properties": {
        "eventId": {
          "type": "string",
          "format": "int64",
          "description": "Monotonically increasing event number, starts at 1."
        },
        "eventTime": {
          "type": "string",
          "format": "date-time"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "taskId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "workerMayIgnore": {
          "type": "boolean",
          "description": "Set to true when the SDK may ignore the event as it does not impact workflow state or\ninformation in any way that the SDK need be concerned with. If an SDK encounters an event\ntype which it does not understand, it must error unless this is true. If it is true, it's\nacceptable for the event type and/or attributes to be uninterpretable."
        },
        "workflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionStartedEventAttributes"
        },
        "workflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCompletedEventAttributes"
        },
        "workflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionFailedEventAttributes"
        },
        "workflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTimedOutEventAttributes"
        },
        "workflowTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskScheduledEventAttributes"
        },
        "workflowTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskStartedEventAttributes"
        },
        "workflowTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskCompletedEventAttributes"
        },
        "workflowTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskTimedOutEventAttributes"
        },
        "workflowTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskFailedEventAttributes"
        },
        "activityTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskScheduledEventAttributes"
        },
        "activityTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskStartedEventAttributes"
        },
        "activityTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCompletedEventAttributes"
        },
        "activityTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskFailedEventAttributes"
        },
        "activityTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskTimedOutEventAttributes"
        },
        "timerStartedEventAttributes": {
          "$ref": "#/definitions/v1TimerStartedEventAttributes"
        },
        "timerFiredEventAttributes": {
          "$ref": "#/definitions/v1TimerFiredEventAttributes"
        },
        "activityTaskCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCancelRequestedEventAttributes"
        },
        "activityTaskCanceledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCanceledEventAttributes"
        },
        "timerCanceledEventAttributes": {
          "$ref": "#/definitions/v1TimerCanceledEventAttributes"
        },
        "markerRecordedEventAttributes": {
          "$ref": "#/definitions/v1MarkerRecordedEventAttributes"
        },
        "workflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionSignaledEventAttributes"
        },
        "workflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTerminatedEventAttributes"
        },
        "workflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCanceledEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionContinuedAsNewEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionContinuedAsNewEventAttributes"
        },
        "startChildWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionInitiatedEventAttributes"
        },
        "startChildWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionStartedEventAttributes"
        },
        "childWorkflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCompletedEventAttributes"
        },
        "childWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCanceledEventAttributes"
        },
        "childWorkflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTimedOutEventAttributes"
        },
        "childWorkflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTerminatedEventAttributes"
        },
        "signalExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "signalExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionSignaledEventAttributes"
        },
        "upsertWorkflowSearchAttributesEventAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesEventAttributes"
        },
        "workflowUpdateRequestedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowUpdateRequestedEventAttributes"
        },
        "workflowUpdateAcceptedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowUpdateAcceptedEventAttributes"
        },
        "workflowUpdateCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowUpdateCompletedEventAttributes"
        },
        "workflowPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedExternallyEventAttributes"
        },
        "activityPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1ActivityPropertiesModifiedExternallyEventAttributes"
        },
        "workflowPropertiesModifiedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedEventAttributes"
        }
      },
      "description": "History events are the method by which Temporal SDKs advance (or recreate) workflow state.\nSee the `EventType` enum for more info about what each event is for."
    },
    "v1HistoryEventFilterType": {
      "type": "string",
      "enum": [
        "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
        "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
        "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
      ],
      "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
    },
    "v1IndexedValueType": {
      "type": "string",
      "enum": [
        "INDEXED_VALUE_TYPE_UNSPECIFIED",
        "INDEXED_VALUE_TYPE_TEXT",
        "INDEXED_VALUE_TYPE_KEYWORD",
        "INDEXED_VALUE_TYPE_INT",
        "INDEXED_VALUE_TYPE_DOUBLE",
        "INDEXED_VALUE_TYPE_BOOL",
        "INDEXED_VALUE_TYPE_DATETIME"
      ],
      "default": "INDEXED_VALUE_TYPE_UNSPECIFIED"
    },
    "v1IntervalSpec": {
      "type": "object",
      "properties": {
        "interval": {
          "type": "string"
        },
        "phase": {
          "type": "string"
        }
      },
      "description": "IntervalSpec matches times that can be expressed as:\nepoch + n * interval + phase\nwhere n is an integer.\nphase defaults to zero if missing. interval is required.\nBoth interval and phase must be non-negative and are truncated to the nearest\nsecond before any calculations.\nFor example, an interval of 1 hour with phase of zero would match every hour,\non the hour. The same interval but a phase of 19 minutes would match every\nxx:19:00. An interval of 28 days with phase zero would match\n2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3\ndays, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead."
    },
    "v1ListArchivedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListClosedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListNamespacesResponse": {
      "type": "object",
      "properties": {
        "namespaces": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1DescribeNamespaceResponse"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListOpenWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListScheduleMatchingTimesResponse": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      }
    },
    "v1ListSchedulesResponse": {
      "type": "object",
      "properties": {
        "schedules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ScheduleListEntry"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListTaskQueuePartitionsResponse": {
      "type": "object",
      "properties": {
        "activityTaskQueuePartitions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        },
        "workflowTaskQueuePartitions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        }
      }
    },
    "v1ListWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1MarkerRecordedEventAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string",
          "description": "Workers use this to identify the \"types\" of various markers. Ex: Local activity, side effect."
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          },
          "title": "Serialized information recorded in the marker"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "description": "Some uses of markers, like a local activity, could \"fail\". If they did that is recorded here."
        }
      }
    },
    "v1Memo": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "A user-defined set of *unindexed* fields that are exposed when listing/searching workflows"
    },
    "v1ModifyWorkflowPropertiesCommandAttributes": {
      "type": "object",
      "properties": {
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1NamespaceConfig": {
      "type": "object",
      "properties": {
        "workflowExecutionRetentionTtl": {
          "type": "string"
        },
        "badBinaries": {
          "$ref": "#/definitions/v1BadBinaries"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        }
      }
    },
    "v1NamespaceFilter": {
      "type": "object",
      "properties": {
        "includeDeleted": {
          "type": "boolean",
          "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet."
        }
      }
    },
    "v1NamespaceInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "id": {
          "type": "string"
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Whether scheduled workflows are supported on this namespace. This is only needed\ntemporarily while the feature is experimental, so we can give it a high tag."
        }
      }
    },
    "v1NamespaceReplicationConfig": {
      "type": "object",
      "properties": {
        "activeClusterName": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "state": {
          "$ref": "#/definitions/v1ReplicationState"
        }
      }
    },
    "v1NamespaceState": {
      "type": "string",
      "enum": [
        "NAMESPACE_STATE_UNSPECIFIED",
        "NAMESPACE_STATE_REGISTERED",
        "NAMESPACE_STATE_DEPRECATED",
        "NAMESPACE_STATE_DELETED"
      ],
      "default": "NAMESPACE_STATE_UNSPECIFIED"
    },
    "v1NewWorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      },
      "description": "NewWorkflowExecutionInfo is a shared message that encapsulates all the\nrequired arguments to starting a workflow in different contexts."
    },
    "v1ParentClosePolicy": {
      "type": "string",
      "enum": [
        "PARENT_CLOSE_POLICY_UNSPECIFIED",
        "PARENT_CLOSE_POLICY_TERMINATE",
        "PARENT_CLOSE_POLICY_ABANDON",
        "PARENT_CLOSE_POLICY_REQUEST_CANCEL"
      ],
      "default": "PARENT_CLOSE_POLICY_UNSPECIFIED",
      "description": "- PARENT_CLOSE_POLICY_TERMINATE: The child workflow will also terminate\n - PARENT_CLOSE_POLICY_ABANDON: The child workflow will do nothing\n - PARENT_CLOSE_POLICY_REQUEST_CANCEL: Cancellation will be requested of the child workflow",
      "title": "Defines how child workflows will react to their parent completing"
    },
    "v1PatchScheduleResponse": {
      "type": "object"
    },
    "v1Payload": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          }
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Represents some binary (byte array) data (ex: activity input parameters or workflow result) with\nmetadata which describes this binary data (format, encoding, encryption, etc). Serialization\nof the data may be user-defined."
    },
    "v1Payloads": {
      "type": "object",
      "properties": {
        "payloads": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "See `Payload`"
    },
    "v1PendingActivityInfo": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "state": {
          "$ref": "#/definitions/v1PendingActivityState"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        },
        "lastHeartbeatTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastStartedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "expirationTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastFailure": {
          "$ref": "#/definitions/v1Failure"
        },
        "lastWorkerIdentity": {
          "type": "string"
        }
      }
    },
    "v1PendingActivityState": {
      "type": "string",
      "enum": [
        "PENDING_ACTIVITY_STATE_UNSPECIFIED",
        "PENDING_ACTIVITY_STATE_SCHEDULED",
        "PENDING_ACTIVITY_STATE_STARTED",
        "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED"
      ],
      "default": "PENDING_ACTIVITY_STATE_UNSPECIFIED"
    },
    "v1PendingChildExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "workflowTypeName": {
          "type": "string"
        },
        "initiatedId": {
          "type": "string",
          "format": "int64"
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        }
      }
    },
    "v1PendingWorkflowTaskInfo": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1PendingWorkflowTaskState"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "originalScheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.\nHeartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command\nIn this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds\nsome threshold, the workflow task will be forced timeout."
        },
        "startedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1PendingWorkflowTaskState": {
      "type": "string",
      "enum": [
        "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED",
        "PENDING_WORKFLOW_TASK_STATE_SCHEDULED",
        "PENDING_WORKFLOW_TASK_STATE_STARTED"
      ],
      "default": "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED"
    },
    "v1PollActivityTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowNamespace": {
          "type": "string",
          "title": "The namespace the workflow which requested this activity lives in"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "Type of the requesting workflow"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the requesting workflow"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string",
          "description": "The autogenerated or user specified identifier of this activity. Can be used to complete the\nactivity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage\nhas resolved, but unique IDs for every activity invocation is a good idea."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers specified by the scheduling workflow. Commonly used to propagate contextual info\nfrom the workflow to its activities. For example, tracing contexts."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arguments to the activity invocation"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Details of the last heartbeat that was recorded for this activity as of the time this task\nwas delivered."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task first scheduled"
        },
        "currentAttemptScheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task attempt scheduled"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task started (this attempt)"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of attempts to perform this activity"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)",
          "title": "First scheduled -\u003e final result reported timeout"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)",
          "title": "Current attempt start -\u003e final result reported timeout"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Window within which the activity must report a heartbeat, or be timed out."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "This is the retry policy the service uses which may be different from the one provided\n(or not) during activity scheduling. The service can override the provided one if some\nvalues are not specified or exceed configured system limits."
        }
      }
    },
    "v1PollWorkflowTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "previousStartedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The last workflow task started event which was processed by some worker for this execution.\nWill be zero if no task has ever started."
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the most recent workflow task started event, which will have been generated as a\nresult of this poll request being served."
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "Starting at 1, the number of attempts to complete this task by any worker."
        },
        "backlogCountHint": {
          "type": "string",
          "format": "int64",
          "description": "A hint that there are more tasks already present in this task queue. Can be used to\nprioritize draining a sticky queue before polling from a normal queue."
        },
        "history": {
          "$ref": "#/definitions/v1History",
          "description": "The history for this workflow, which will either be complete or partial. Partial histories\nare sent to workers who have signaled that they are using a sticky queue when completing\na workflow task."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "description": "Will be set if there are more history events than were included in this response. Such events\nshould be fetched via `GetWorkflowExecutionHistory`."
        },
        "query": {
          "$ref": "#/definitions/v1WorkflowQuery",
          "description": "Legacy queries appear in this field. The query must be responded to via\n`RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on\nclosed workflows) then the `history` field will be populated with the entire history. It\nmay also be populated if this task originates on a non-sticky queue."
        },
        "workflowExecutionTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "description": "The task queue this task originated from, which will always be the original non-sticky name\nfor the queue, even if this response came from polling a sticky queue."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When this task was scheduled by the server"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "description": "When the current workflow task started event was generated, meaning the current attempt."
        },
        "queries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1WorkflowQuery"
          },
          "title": "Queries that should be executed after applying the history in this task. Responses should be\nattached to `RespondWorkflowTaskCompletedRequest::query_results`"
        }
      }
    },
    "v1PollerInfo": {
      "type": "object",
      "properties": {
        "lastAccessTime": {
          "type": "string",
          "format": "date-time",
          "title": "Unix Nano"
        },
        "identity": {
          "type": "string"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "workerVersioningId": {
          "$ref": "#/definitions/v1VersionId",
          "description": "If a worker has specified an ID for use with the worker versioning feature while polling,\nthat id must appear here."
        }
      }
    },
    "v1QueryRejectCondition": {
      "type": "string",
      "enum": [
        "QUERY_REJECT_CONDITION_UNSPECIFIED",
        "QUERY_REJECT_CONDITION_NONE",
        "QUERY_REJECT_CONDITION_NOT_OPEN",
        "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY"
      ],
      "default": "QUERY_REJECT_CONDITION_UNSPECIFIED",
      "description": " - QUERY_REJECT_CONDITION_NONE: None indicates that query should not be rejected.\n - QUERY_REJECT_CONDITION_NOT_OPEN: NotOpen indicates that query should be rejected if workflow is not open.\n - QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY: NotCompletedCleanly indicates that query should be rejected if workflow did not complete cleanly."
    },
    "v1QueryRejected": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1QueryResultType": {
      "type": "string",
      "enum": [
        "QUERY_RESULT_TYPE_UNSPECIFIED",
        "QUERY_RESULT_TYPE_ANSWERED",
        "QUERY_RESULT_TYPE_FAILED"
      ],
      "default": "QUERY_RESULT_TYPE_UNSPECIFIED"
    },
    "v1QueryWorkflowResponse": {
      "type": "object",
      "properties": {
        "queryResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "queryRejected": {
          "$ref": "#/definitions/v1QueryRejected"
        }
      }
    },
    "v1Range": {
      "type": "object",
      "properties": {
        "start": {
          "type": "integer",
          "format": "int32",
          "description": "Start of range (inclusive)."
        },
        "end": {
          "type": "integer",
          "format": "int32",
          "description": "End of range (inclusive)."
        },
        "step": {
          "type": "integer",
          "format": "int32",
          "description": "Step (optional, default 1)."
        }
      },
      "description": "Range represents a set of integer values, used to match fields of a calendar\ntime in StructuredCalendarSpec. If end \u003c start, then end is interpreted as\nequal to start. This means you can use a Range with start set to a value, and\nend and step unset (defaulting to 0) to represent a single value."
    },
    "v1RecordActivityTaskHeartbeatByIdResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        }
      }
    },
    "v1RecordActivityTaskHeartbeatResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        }
      }
    },
    "v1RecordMarkerCommandAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string"
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          }
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure"
        }
      }
    },
    "v1RegisterNamespaceRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "workflowExecutionRetentionPeriod": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "activeClusterName": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "securityToken": {
          "type": "string"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        }
      }
    },
    "v1RegisterNamespaceResponse": {
      "type": "object"
    },
    "v1ReleaseInfo": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string"
        },
        "releaseTime": {
          "type": "string",
          "format": "date-time"
        },
        "notes": {
          "type": "string"
        }
      },
      "description": "ReleaseInfo contains information about specific version of temporal."
    },
    "v1ReplicationState": {
      "type": "string",
      "enum": [
        "REPLICATION_STATE_UNSPECIFIED",
        "REPLICATION_STATE_NORMAL",
        "REPLICATION_STATE_HANDOVER"
      ],
      "default": "REPLICATION_STATE_UNSPECIFIED"
    },
    "v1RequestCancelActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled."
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1CancelExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed to cancel.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure\ncorresponds to"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "The namespace the workflow to be cancelled lives in.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1ResetPointInfo": {
      "type": "object",
      "properties": {
        "binaryChecksum": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "firstWorkflowTaskCompletedId": {
          "type": "string",
          "format": "int64"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "expireTime": {
          "type": "string",
          "format": "date-time",
          "description": "(-- api-linter: core::0214::resource-expiry=disabled\n    aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)\nThe time that the run is deleted due to retention."
        },
        "resettable": {
          "type": "boolean",
          "description": "false if the reset point has pending childWFs/reqCancels/signalExternals."
        }
      }
    },
    "v1ResetPoints": {
      "type": "object",
      "properties": {
        "points": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ResetPointInfo"
          }
        }
      }
    },
    "v1ResetReapplyType": {
      "type": "string",
      "enum": [
        "RESET_REAPPLY_TYPE_UNSPECIFIED",
        "RESET_REAPPLY_TYPE_SIGNAL",
        "RESET_REAPPLY_TYPE_NONE"
      ],
      "default": "RESET_REAPPLY_TYPE_UNSPECIFIED",
      "title": "Reset reapplay(replay) options\n* RESET_REAPPLY_TYPE_SIGNAL (default) - Signals are reapplied when workflow is reset\n* RESET_REAPPLY_TYPE_NONE - nothing is reapplied"
    },
    "v1ResetStickyTaskQueueResponse": {
      "type": "object"
    },
    "v1ResetWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string"
        }
      }
    },
    "v1ResetWorkflowFailureInfo": {
      "type": "object",
      "properties": {
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1RespondActivityTaskCanceledByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCanceledResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskFailedByIdResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondActivityTaskFailedResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondQueryTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondWorkflowTaskCompletedResponse": {
      "type": "object",
      "properties": {
        "workflowTask": {
          "$ref": "#/definitions/v1PollWorkflowTaskQueueResponse",
          "title": "See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`"
        },
        "activityTasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PollActivityTaskQueueResponse"
          },
          "title": "See `ScheduleActivityTaskCommandAttributes::request_start`"
        }
      }
    },
    "v1RespondWorkflowTaskFailedResponse": {
      "type": "object"
    },
    "v1RetryPolicy": {
      "type": "object",
      "properties": {
        "initialInterval": {
          "type": "string",
          "description": "Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries."
        },
        "backoffCoefficient": {
          "type": "number",
          "format": "double",
          "description": "Coefficient used to calculate the next retry interval.\nThe next retry interval is previous interval multiplied by the coefficient.\nMust be 1 or larger."
        },
        "maximumInterval": {
          "type": "string",
          "description": "Maximum interval between retries. Exponential backoff leads to interval increase.\nThis value is the cap of the increase. Default is 100x of the initial interval."
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n1 disables retries. 0 means unlimited (up to the timeouts)"
        },
        "nonRetryableErrorTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that\nthis is not a substring match, the error *type* (not message) must match exactly."
        }
      },
      "title": "How retries ought to be handled, usable by both workflows and activities"
    },
    "v1RetryState": {
      "type": "string",
      "enum": [
        "RETRY_STATE_UNSPECIFIED",
        "RETRY_STATE_IN_PROGRESS",
        "RETRY_STATE_NON_RETRYABLE_FAILURE",
        "RETRY_STATE_TIMEOUT",
        "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
        "RETRY_STATE_RETRY_POLICY_NOT_SET",
        "RETRY_STATE_INTERNAL_SERVER_ERROR",
        "RETRY_STATE_CANCEL_REQUESTED"
      ],
      "default": "RETRY_STATE_UNSPECIFIED"
    },
    "v1ScanWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1Schedule": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec"
        },
        "action": {
          "$ref": "#/definitions/v1ScheduleAction"
        },
        "policies": {
          "$ref": "#/definitions/v1SchedulePolicies"
        },
        "state": {
          "$ref": "#/definitions/v1ScheduleState"
        }
      }
    },
    "v1ScheduleAction": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1NewWorkflowExecutionInfo",
          "description": "All fields of NewWorkflowExecutionInfo are valid except for:\n- workflow_id_reuse_policy\n- cron_schedule\nThe workflow id of the started workflow may not match this exactly,\nit may have a timestamp appended for uniqueness."
        }
      }
    },
    "v1ScheduleActionResult": {
      "type": "object",
      "properties": {
        "scheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (according to the schedule, including jitter)."
        },
        "actualTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (real time)."
        },
        "startWorkflowResult": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "If action was start_workflow:"
        }
      }
    },
    "v1ScheduleActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for activity completion. The \"schedule\" time\nis when the activity is initially scheduled, not when the most recent retry is scheduled.\nLimits how long retries will be attempted. Either this or `start_to_close_timeout` must be\nspecified. When not specified, defaults to the workflow execution timeout.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)",
          "title": "Limits the time an activity task can stay in a task queue before a worker picks it up. The\n\"schedule\" time is when the most recent retry is scheduled. This timeout should usually not\nbe set: it's useful in specific scenarios like worker-specific task queues. This timeout is\nalways non retryable, as all a retry would achieve is to put it back into the same queue.\nDefaults to `schedule_to_close_timeout` or workflow execution timeout if that is not\nspecified. More info:\nhttps://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are provided by a default retry policy which is controlled through the service's\ndynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has\nelapsed. To disable retries set retry_policy.maximum_attempts to 1."
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to start the activity directly bypassing matching service and worker polling\nThe slot for executing the activity should be reserved when setting this field to true."
        }
      }
    },
    "v1ScheduleInfo": {
      "type": "object",
      "properties": {
        "actionCount": {
          "type": "string",
          "format": "int64",
          "description": "Number of actions taken so far."
        },
        "missedCatchupWindow": {
          "type": "string",
          "format": "int64",
          "description": "Number of times a scheduled action was skipped due to missing the catchup window."
        },
        "overlapSkipped": {
          "type": "string",
          "format": "int64",
          "description": "Number of skipped actions due to overlap."
        },
        "runningWorkflows": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1WorkflowExecution"
          },
          "description": "Currently-running workflows started by this schedule. (There might be\nmore than one if the overlap policy allows overlaps.)\nNote that the run_ids in here are the original execution run ids as\nstarted by the schedule. If the workflows retried, did continue-as-new,\nor were reset, they might still be running but with a different run_id."
        },
        "recentActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "description": "Most recent ten actual action times (including manual triggers)."
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          },
          "description": "Next ten scheduled action times."
        },
        "createTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamps of schedule creation and last update."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time"
        },
        "invalidScheduleError": {
          "type": "string"
        }
      }
    },
    "v1ScheduleListEntry": {
      "type": "object",
      "properties": {
        "scheduleId": {
          "type": "string"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleListInfo"
        }
      },
      "description": "ScheduleListEntry is returned by ListSchedules."
    },
    "v1ScheduleListInfo": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec",
          "title": "From spec:\nSome fields are dropped from this copy of spec: timezone_data"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "From action:\nAction is a oneof field, but we need to encode this in JSON and oneof fields don't work\nwell with JSON. If action is start_workflow, this is set:"
        },
        "notes": {
          "type": "string",
          "title": "From state:"
        },
        "paused": {
          "type": "boolean"
        },
        "recentActions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "title": "From info (maybe fewer entries):"
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "description": "ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo\nthat's returned in ListSchedules."
    },
    "v1ScheduleOverlapPolicy": {
      "type": "string",
      "enum": [
        "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
        "SCHEDULE_OVERLAP_POLICY_SKIP",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
        "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
        "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
        "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
      ],
      "default": "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
      "description": "ScheduleOverlapPolicy controls what happens when a workflow would be started\nby a schedule, and is already running.\n\n - SCHEDULE_OVERLAP_POLICY_SKIP: SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the\nworkflow completes, the next scheduled event after that time will be considered.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ONE: SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the\ncurrent one completes, but only buffer one start in this way. If another start is\nsupposed to happen when the workflow is running, and one is already buffered, then\nonly the first one will be started after the running workflow finishes.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ALL: SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all\nhappen sequentially, immediately after the running workflow completes.\n - SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER: SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow\nrunning, cancel it, and start the new one after the old one completes cancellation.\n - SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER: SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow\nrunning, terminate it and start the new one immediately.\n - SCHEDULE_OVERLAP_POLICY_ALLOW_ALL: SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.\nNote that with this policy, last completion result and last failure will not be\navailable since workflows are not sequential."
    },
    "v1SchedulePatch": {
      "type": "object",
      "properties": {
        "triggerImmediately": {
          "$ref": "#/definitions/v1TriggerImmediatelyRequest",
          "description": "If set, trigger one action immediately."
        },
        "backfillRequest": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1BackfillRequest"
          },
          "description": "If set, runs though the specified time period(s) and takes actions as if that time\npassed by right now, all at once. The overlap policy can be overridden for the\nscope of the backfill."
        },
        "pause": {
          "type": "string",
          "description": "If set, change the state to paused or unpaused (respectively) and set the\nnotes field to the value of the string."
        },
        "unpause": {
          "type": "string"
        }
      }
    },
    "v1SchedulePolicies": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "Policy for overlaps.\nNote that this can be changed after a schedule has taken some actions,\nand some changes might produce unintuitive results. In general, the later\npolicy overrides the earlier policy."
        },
        "catchupWindow": {
          "type": "string",
          "description": "Policy for catchups:\nIf the Temporal server misses an action due to one or more components\nbeing down, and comes back up, the action will be run if the scheduled\ntime is within this window from the current time.\nThis value defaults to 60 seconds, and can't be less than 10 seconds."
        },
        "pauseOnFailure": {
          "type": "boolean",
          "description": "If true, and a workflow run fails or times out, turn on \"paused\".\nThis applies after retry policies: the full chain of retries must fail to\ntrigger a pause here."
        }
      }
    },
    "v1ScheduleSpec": {
      "type": "object",
      "properties": {
        "structuredCalendar": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "cronString": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "cron_string holds a traditional cron specification as a string. It\naccepts 5, 6, or 7 fields, separated by spaces, and interprets them the\nsame way as CalendarSpec.\n5 fields:         minute, hour, day_of_month, month, day_of_week\n6 fields:         minute, hour, day_of_month, month, day_of_week, year\n7 fields: second, minute, hour, day_of_month, month, day_of_week, year\nIf year is not given, it defaults to *. If second is not given, it\ndefaults to 0.\nShorthands @yearly, @monthly, @weekly, @daily, and @hourly are also\naccepted instead of the 5-7 time fields.\nOptionally, the string can be preceded by CRON_TZ=\u003ctimezone name\u003e or\nTZ=\u003ctimezone name\u003e, which will get copied to timezone_name. (There must\nnot also be a timezone_name present.)\nOptionally \"#\" followed by a comment can appear at the end of the string.\nNote that the special case that some cron implementations have for\ntreating day_of_month and day_of_week as \"or\" instead of \"and\" when both\nare set is not implemented.\n@every \u003cinterval\u003e[/\u003cphase\u003e] is accepted and gets compiled into an\nIntervalSpec instead. \u003cinterval\u003e and \u003cphase\u003e should be a decimal integer\nwith a unit suffix s, m, h, or d."
        },
        "calendar": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "interval": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1IntervalSpec"
          },
          "description": "Interval-based specifications of times."
        },
        "excludeCalendar": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Any timestamps matching any of exclude_* will be skipped."
        },
        "excludeStructuredCalendar": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          }
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "If start_time is set, any timestamps before start_time will be skipped.\n(Together, start_time and end_time make an inclusive interval.)"
        },
        "endTime": {
          "type": "string",
          "format": "date-time",
          "description": "If end_time is set, any timestamps after end_time will be skipped."
        },
        "jitter": {
          "type": "string",
          "title": "All timestamps will be incremented by a random value from 0 to this\namount of jitter. Default: 0"
        },
        "timezoneName": {
          "type": "string",
          "description": "Time zone to interpret all calendar-based specs in.\n\nIf unset, defaults to UTC. We recommend using UTC for your application if\nat all possible, to avoid various surprising properties of time zones.\n\nTime zones may be provided by name, corresponding to names in the IANA\ntime zone database (see https://www.iana.org/time-zones). The definition\nwill be loaded by the Temporal server from the environment it runs in.\n\nIf your application requires more control over the time zone definition\nused, it may pass in a complete definition in the form of a TZif file\nfrom the time zone database. If present, this will be used instead of\nloading anything from the environment. You are then responsible for\nupdating timezone_data when the definition changes.\n\nCalendar spec matching is based on literal matching of the clock time\nwith no special handling of DST: if you write a calendar spec that fires\nat 2:30am and specify a time zone that follows DST, that action will not\nbe triggered on the day that has no 2:30am. Similarly, an action that\nfires at 1:30am will be triggered twice on the day that has two 1:30s.\n\nAlso note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC)."
        },
        "timezoneData": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "ScheduleSpec is a complete description of a set of absolute timestamps\n(possibly infinite) that an action should occur at. The meaning of a\nScheduleSpec depends only on its contents and never changes, except that the\ndefinition of a time zone can change over time (most commonly, when daylight\nsaving time policy changes for an area). To create a totally self-contained\nScheduleSpec, use UTC or include timezone_data.\n\nFor input, you can provide zero or more of: structured_calendar, calendar,\ncron_string, interval, and exclude_structured_calendar, and all of them will\nbe used (the schedule will take action at the union of all of their times,\nminus the ones that match exclude_structured_calendar).\n\nOn input, calendar and cron_string fields will be compiled into\nstructured_calendar (and maybe interval and timezone_name), so if you\nDescribe a schedule, you'll see only structured_calendar, interval, etc."
    },
    "v1ScheduleState": {
      "type": "object",
      "properties": {
        "notes": {
          "type": "string",
          "description": "Informative human-readable message with contextual notes, e.g. the reason\na schedule is paused. The system may overwrite this message on certain\nconditions, e.g. when pause-on-failure happens."
        },
        "paused": {
          "type": "boolean",
          "description": "If true, do not take any actions based on the schedule spec."
        },
        "limitedActions": {
          "type": "boolean",
          "description": "If limited_actions is true, decrement remaining_actions after each\naction, and do not take any more scheduled actions if remaining_actions\nis zero. Actions may still be taken by explicit request (i.e. trigger\nimmediately or backfill). Skipped actions (due to overlap policy) do not\ncount against remaining actions."
        },
        "remainingActions": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1SearchAttributes": {
      "type": "object",
      "properties": {
        "indexedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.\nThe payload is not serialized in a user-defined way."
    },
    "v1ServerFailureInfo": {
      "type": "object",
      "properties": {
        "nonRetryable": {
          "type": "boolean"
        }
      }
    },
    "v1Severity": {
      "type": "string",
      "enum": [
        "SEVERITY_UNSPECIFIED",
        "SEVERITY_HIGH",
        "SEVERITY_MEDIUM",
        "SEVERITY_LOW"
      ],
      "default": "SEVERITY_UNSPECIFIED"
    },
    "v1SignalExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "description": "The workflow author-defined name of the signal to send to the workflow."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized value(s) to provide with the signal."
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed by the workflow that is sending a signal to the external \nworkflow that is receiving this signal."
        }
      }
    },
    "v1SignalExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1SignalExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed the signal.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1SignalExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-signalled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "title": "name/type of the signal to fire in the external workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized arguments to provide to the signal handler"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1SignalWithStartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string"
        }
      }
    },
    "v1SignalWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1StartBatchOperationResponse": {
      "type": "object"
    },
    "v1StartChildWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Establish a cron schedule for the child workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1StartChildWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1StartChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "cause": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedCause"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1StartChildWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this child runs on a cron schedule, it will appear here"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1StartTimeFilter": {
      "type": "object",
      "properties": {
        "earliestTime": {
          "type": "string",
          "format": "date-time"
        },
        "latestTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1StartTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "description": "An id for the timer, currently live timers must have different ids. Typically autogenerated\nby the SDK."
        },
        "startToFireTimeout": {
          "type": "string",
          "description": "How long until the timer fires, producing a `TIMER_FIRED` event.\n\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        }
      }
    },
    "v1StartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string"
        }
      }
    },
    "v1StatusFilter": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1StickyExecutionAttributes": {
      "type": "object",
      "properties": {
        "workerTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "title": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
        }
      }
    },
    "v1StructuredCalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match seconds (0-59)"
        },
        "minute": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match minutes (0-59)"
        },
        "hour": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match hours (0-23)"
        },
        "dayOfMonth": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match days of the month (1-31)\n(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: standard name of field --)"
        },
        "month": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match months (1-12)"
        },
        "year": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match years."
        },
        "dayOfWeek": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match days of the week (0-6; 0 is Sunday)."
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "title": "StructuredCalendarSpec describes an event specification relative to the\ncalendar, in a form that's easy to work with programmatically. Each field can\nbe one or more ranges.\nA timestamp matches if at least one range of each field matches the\ncorresponding fields of the timestamp, except for year: if year is missing,\nthat means all years match. For all fields besides year, at least one Range\nmust be present to match anything.\nTODO: add relative-to-end-of-month\nTODO: add nth day-of-week in month"
    },
    "v1TaskIdBlock": {
      "type": "object",
      "properties": {
        "startId": {
          "type": "string",
          "format": "int64"
        },
        "endId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1TaskQueue": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/v1TaskQueueKind",
          "description": "Default: TASK_QUEUE_KIND_NORMAL."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/task-queues/"
    },
    "v1TaskQueueKind": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_KIND_UNSPECIFIED",
        "TASK_QUEUE_KIND_NORMAL",
        "TASK_QUEUE_KIND_STICKY"
      ],
      "default": "TASK_QUEUE_KIND_UNSPECIFIED",
      "description": "The task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
      "title": "- TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history"
    },
    "v1TaskQueueMetadata": {
      "type": "object",
      "properties": {
        "maxTasksPerSecond": {
          "type": "number",
          "format": "double",
          "title": "Allows throttling dispatch of tasks from this queue"
        }
      },
      "title": "Only applies to activity task queues"
    },
    "v1TaskQueuePartitionMetadata": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "ownerHostName": {
          "type": "string"
        }
      }
    },
    "v1TaskQueueStatus": {
      "type": "object",
      "properties": {
        "backlogCountHint": {
          "type": "string",
          "format": "int64"
        },
        "readLevel": {
          "type": "string",
          "format": "int64"
        },
        "ackLevel": {
          "type": "string",
          "format": "int64"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "taskIdBlock": {
          "$ref": "#/definitions/v1TaskIdBlock"
        }
      }
    },
    "v1TaskQueueType": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_TYPE_UNSPECIFIED",
        "TASK_QUEUE_TYPE_WORKFLOW",
        "TASK_QUEUE_TYPE_ACTIVITY"
      ],
      "default": "TASK_QUEUE_TYPE_UNSPECIFIED",
      "description": " - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue."
    },
    "v1TerminateWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1TerminatedFailureInfo": {
      "type": "object"
    },
    "v1TimeoutFailureInfo": {
      "type": "object",
      "properties": {
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1TimeoutType": {
      "type": "string",
      "enum": [
        "TIMEOUT_TYPE_UNSPECIFIED",
        "TIMEOUT_TYPE_START_TO_CLOSE",
        "TIMEOUT_TYPE_SCHEDULE_TO_START",
        "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
        "TIMEOUT_TYPE_HEARTBEAT"
      ],
      "default": "TIMEOUT_TYPE_UNSPECIFIED"
    },
    "v1TimerCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "identity": {
          "type": "string",
          "title": "The id of the worker who requested this cancel"
        }
      }
    },
    "v1TimerFiredEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        }
      }
    },
    "v1TimerStartedEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The worker/user assigned id for this timer"
        },
        "startToFireTimeout": {
          "type": "string",
          "description": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)",
          "title": "How long until this timer fires"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1TriggerImmediatelyRequest": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "Override overlap policy for this one request."
        }
      }
    },
    "v1UpdateNamespaceInfo": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose.\nIf data already exists on the namespace, \nthis will merge with the existing key values."
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState",
          "description": "New namespace state, server will reject if transition is not allowed.\nAllowed transitions are:\n Registered -\u003e [ Deleted | Deprecated | Handover ]\n Handover -\u003e [ Registered ]\nDefault is NAMESPACE_STATE_UNSPECIFIED which is do not change state."
        }
      }
    },
    "v1UpdateNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        }
      }
    },
    "v1UpdateScheduleResponse": {
      "type": "object"
    },
    "v1UpsertWorkflowSearchAttributesCommandAttributes": {
      "type": "object",
      "properties": {
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1UpsertWorkflowSearchAttributesEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1VersionId": {
      "type": "object",
      "properties": {
        "workerBuildId": {
          "type": "string",
          "title": "An opaque whole-worker identifier"
        }
      },
      "description": "Used by the worker versioning APIs, represents a specific version of something\nCurrently, that's just a whole-worker id. In the future, if we support\nWASM workflow bundle based versioning, for example, then the inside of this\nmessage may become a oneof of different version types."
    },
    "v1VersionInfo": {
      "type": "object",
      "properties": {
        "current": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "recommended": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "instructions": {
          "type": "string"
        },
        "alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1Alert"
          }
        },
        "lastUpdateTime": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions."
    },
    "v1WorkflowExecution": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      },
      "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
    },
    "v1WorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "type": "string",
          "title": "User provided reason for requesting cancellation\nTODO: shall we create a new field with name \"reason\" and deprecate this one?"
        },
        "externalInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?"
        },
        "externalWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker or client who requested this cancel"
        }
      }
    },
    "v1WorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1WorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized result of workflow completion (ie: The return value of the workflow function)"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionConfig": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "workflowExecutionTimeout": {
          "type": "string"
        },
        "workflowRunTimeout": {
          "type": "string"
        },
        "defaultWorkflowTaskTimeout": {
          "type": "string"
        }
      }
    },
    "v1WorkflowExecutionContinuedAsNewEventAttributes": {
      "type": "object",
      "properties": {
        "newExecutionRunId": {
          "type": "string",
          "title": "The run ID of the new workflow started by this continue-as-new"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "backoffStartInterval": {
          "type": "string",
          "title": "TODO: How and is this used?"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "description": "TODO: David are these right?\nDeprecated. If a workflow's retry policy would cause a new run to start when the current one\nhas failed, this field would be populated with that failure. Now (when supported by server\nand sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "TODO: Is this the result of *this* workflow as it continued-as-new?"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1WorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "title": "Serialized result of workflow failure (ex: An exception thrown, or error returned)"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionFilter": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      }
    },
    "v1WorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "type": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "startTime": {
          "type": "string",
          "format": "date-time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time"
        },
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        },
        "historyLength": {
          "type": "string",
          "format": "int64"
        },
        "parentNamespaceId": {
          "type": "string"
        },
        "parentExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "executionTime": {
          "type": "string",
          "format": "date-time"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "autoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "taskQueue": {
          "type": "string"
        },
        "stateTransitionCount": {
          "type": "string",
          "format": "int64"
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1WorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "signalName": {
          "type": "string",
          "title": "The name/type of the signal to fire"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Will be deserialized and provided as argument(s) to the signal handler"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker/client who sent this signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the sender of the signal and copied by temporal \nserver into the workflow task."
        }
      }
    },
    "v1WorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "parentWorkflowNamespace": {
          "type": "string",
          "description": "If this workflow is a child, the namespace our parent lives in.\nSDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only."
        },
        "parentWorkflowNamespaceId": {
          "type": "string"
        },
        "parentWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about parent workflow execution that initiated the child workflow these attributes belong to.\nIf the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated."
        },
        "parentInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "EventID of the child execution initiated event in parent workflow"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "SDK will deserialize this and provide it as arguments to the workflow function"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "continuedExecutionRunId": {
          "type": "string",
          "description": "Run id of the previous workflow which continued-as-new or retired or cron executed into this\nworkflow."
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "continuedFailure": {
          "$ref": "#/definitions/v1Failure"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "originalExecutionRunId": {
          "type": "string",
          "description": "This is the run id when the WorkflowExecutionStarted event was written.\nA workflow reset changes the execution run_id, but preserves this field."
        },
        "identity": {
          "type": "string",
          "title": "Identity of the client who requested this execution"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.\nUsed to identify a chain."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times we have tried to execute this workflow"
        },
        "workflowExecutionExpirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The absolute time at which the workflow will be timed out.\nThis is passed without change to the next run/retry of a workflow."
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this workflow runs on a cron schedule, it will appear here"
        },
        "firstWorkflowTaskBackoff": {
          "type": "string",
          "description": "For a cron workflow, this contains the amount of time between when this iteration of\nthe cron workflow was scheduled and when it should run next per its cron_schedule."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "prevAutoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "parentInitiatedEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "Version of the child execution initiated event in parent workflow\nIt should be used together with parent_initiated_event_id to identify\na child initiated event for global namespace"
        }
      },
      "title": "Always the first event in workflow history"
    },
    "v1WorkflowExecutionStatus": {
      "type": "string",
      "enum": [
        "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
        "WORKFLOW_EXECUTION_STATUS_RUNNING",
        "WORKFLOW_EXECUTION_STATUS_COMPLETED",
        "WORKFLOW_EXECUTION_STATUS_FAILED",
        "WORKFLOW_EXECUTION_STATUS_CANCELED",
        "WORKFLOW_EXECUTION_STATUS_TERMINATED",
        "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
        "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
      ],
      "default": "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
      "description": "- WORKFLOW_EXECUTION_STATUS_RUNNING: Value 1 is hardcoded in SQL persistence.",
      "title": "(-- api-linter: core::0216::synonyms=disabled\n    aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)"
    },
    "v1WorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "title": "User/client provided reason for termination"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "identity": {
          "type": "string",
          "title": "id of the client who requested termination"
        }
      }
    },
    "v1WorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowIdReusePolicy": {
      "type": "string",
      "enum": [
        "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
        "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
      ],
      "default": "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
      "description": "Defines how new runs of a workflow with a particular ID may or may not be allowed. Note that\nit is *never* valid to have two actively running instances of the same workflow id.\n\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: Allow starting a workflow execution using the same workflow id.\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: Allow starting a workflow execution using the same workflow id, only when the last\nexecution's final state is one of [terminated, cancelled, timed out, failed].\n - WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: Do not permit re-use of the workflow id for this workflow. Future start workflow requests\ncould potentially change the policy, allowing re-use of the workflow id.\n - WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: If a workflow is running using the same workflow ID, terminate it and start a new one.\nIf no running workflow, then the behavior is the same as ALLOW_DUPLICATE"
    },
    "v1WorkflowPropertiesModifiedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1WorkflowPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "newTaskQueue": {
          "type": "string",
          "description": "If set to a nonempty string, future workflow tasks for this workflow shall be dispatched on\nthe provided queue."
        },
        "newWorkflowTaskTimeout": {
          "type": "string",
          "description": "If set, update the workflow task timeout to this value."
        },
        "newWorkflowRunTimeout": {
          "type": "string",
          "description": "If set, update the workflow run timeout to this value. May be set to 0 for no timeout."
        },
        "newWorkflowExecutionTimeout": {
          "type": "string",
          "description": "If set, update the workflow execution timeout to this value. May be set to 0 for no timeout."
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1WorkflowQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "type": "string",
          "description": "The workflow-author-defined identifier of the query. Typically a function name."
        },
        "queryArgs": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments that will be provided to the query handler."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the caller of the query and copied by temporal \nserver into the workflow task."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/queries/"
    },
    "v1WorkflowQueryResult": {
      "type": "object",
      "properties": {
        "resultType": {
          "$ref": "#/definitions/v1QueryResultType",
          "title": "Did the query succeed or fail?"
        },
        "answer": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Set when the query succeeds with the results"
        },
        "errorMessage": {
          "type": "string",
          "description": "Mutually exclusive with `answer`. Set when the query fails."
        }
      },
      "title": "Answer to a `WorkflowQuery`"
    },
    "v1WorkflowTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who completed this task"
        },
        "binaryChecksum": {
          "type": "string",
          "title": "Binary ID of the worker who completed this task"
        },
        "workerVersioningId": {
          "$ref": "#/definitions/v1VersionId",
          "description": "ID of the worker who picked up this workflow task, or missing if worker\nis not using versioning."
        }
      }
    },
    "v1WorkflowTaskFailedCause": {
      "type": "string",
      "enum": [
        "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
        "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE",
        "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY",
        "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES"
      ],
      "default": "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
      "description": "Workflow tasks can fail for various reasons. Note that some of these reasons can only originate\nfrom the server, and some of them can only originate from the SDK/worker.\n\n - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND: Between starting and completing the workflow task (with a workflow completion command), some\nnew command (like a signal) was processed into workflow history. The outstanding task will be\nfailed with this reason, and a worker must pick up a new task.\n - WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE: The worker wishes to fail the task and have the next one be generated on a normal, not sticky\nqueue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.\n - WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR: The worker encountered a mismatch while replaying history between what was expected, and\nwhat the workflow code actually did."
    },
    "v1WorkflowTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "cause": {
          "$ref": "#/definitions/v1WorkflowTaskFailedCause"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure",
          "title": "The failure details"
        },
        "identity": {
          "type": "string",
          "title": "If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?"
        },
        "baseRunId": {
          "type": "string",
          "description": "The original run id of the workflow. For reset workflow."
        },
        "newRunId": {
          "type": "string",
          "description": "If the workflow is being reset, the new run id."
        },
        "forkEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "TODO: ?"
        },
        "binaryChecksum": {
          "type": "string",
          "title": "If a worker explicitly failed this task, it's binary id"
        }
      }
    },
    "v1WorkflowTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "title": "The task queue this workflow task was enqueued in, which could be a normal or sticky queue"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "(-- api-linter: core::0140::prepositions=disabled\n    aip.dev/not-precedent: \"to\" is used to indicate interval. --)",
          "title": "How long the worker has to process this task once receiving it before it times out"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, how many attempts there have been to complete this task"
        }
      }
    },
    "v1WorkflowTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO: ? Appears unused?"
        },
        "suggestContinueAsNew": {
          "type": "boolean",
          "description": "True if this workflow should continue-as-new soon because its history size (in\neither event count or bytes) is getting large."
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64",
          "description": "Total history size in bytes, which the workflow might use to decide when to\ncontinue-as-new regardless of the suggestion. Note that history event count is\njust the event id of this event, so we don't include it explicitly here."
        }
      }
    },
    "v1WorkflowTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        }
      }
    },
    "v1WorkflowType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a workflow author to define the workflow. Typically, the\nname of a function. This is sometimes referred to as the workflow's \"name\""
    },
    "v1WorkflowTypeFilter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      }
    },
    "v1WorkflowUpdate": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the update to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "name": {
          "type": "string",
          "description": "The name of the update function to invoke on the target workflow."
        },
        "args": {
          "$ref": "#/definitions/v1Payloads",
          "description": "The arguments to pass to the named update function."
        }
      }
    },
    "v1WorkflowUpdateAcceptedEventAttributes": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "updateId": {
          "type": "string"
        }
      }
    },
    "v1WorkflowUpdateCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "systemHeader": {
          "$ref": "#/definitions/v1Header"
        },
        "updateId": {
          "type": "string"
        },
        "success": {
          "$ref": "#/definitions/v1Payloads"
        },
        "failure": {
          "$ref": "#/definitions/v1Failure"
        }
      }
    },
    "v1WorkflowUpdateDurabilityPreference": {
      "type": "string",
      "enum": [
        "WORKFLOW_UPDATE_DURABILITY_PREFERENCE_UNSPECIFIED",
        "WORKFLOW_UPDATE_DURABILITY_PREFERENCE_BYPASS"
      ],
      "default": "WORKFLOW_UPDATE_DURABILITY_PREFERENCE_UNSPECIFIED",
      "description": " - WORKFLOW_UPDATE_DURABILITY_PREFERENCE_UNSPECIFIED: The workflow expresses no preference as to the durability of the\nthe associated update.\n - WORKFLOW_UPDATE_DURABILITY_PREFERENCE_BYPASS: Used by a workflow to indicate that no workflow state mutation occurred\nwhile processing the update and that it wishes that the update not be\nmade durable (and thus not take up space in workflow history)."
    },
    "v1WorkflowUpdateRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "requestId": {
          "type": "string"
        },
        "updateId": {
          "type": "string"
        },
        "update": {
          "$ref": "#/definitions/v1WorkflowUpdate"
        }
      }
    }
  }
}
